// Test simple elaborations
Timepoint.setEpoch("2019-001T00:00:00+0000")
// ParameterListenerImpl.setMaxLoopsWithNoProgress(50)


var t0 : Time = seconds(0.0)
var t5 : Time = seconds(5.0)
var t10 : Time = seconds(10.0)
var t15 : Time = seconds(15.0)
var t20 : Time = seconds(20.0)

// var x : TimeVaryingMap[Real]
// 
// x.setValue(t0, 0.0)
// x.setValue(t5, 5.0)
// x.setValue(t10, 0.0)

var y : TimeVaryingMap[Bool] // = x > 2.0

y.setValue(t0, false)
y.setValue(t5, true)
y.setValue(t10, false)

var z : TimeVaryingMap[Real]
z.setValue(t0, zero)
var zero : Real = 0.0

req elaborates(null, E.class, y)

class E extends DurativeEvent {
    z.setValue(startTime, x)
    var x : Real = 1.0
    // req duration = seconds(5.0)
}
var e : E = E(startTime :: hours(100.0), endTime :: hours(101.0) ) // + seconds(5.0)) // dummy elaboration to prevent AutoGenerated E from messing things up

//// State Machine Simulation ////

// var sm : TimeVaryingMap[State]
// class State
// val s1 : State
// val s2 : State
// 
// sm.setValue(t0, s1)
// sm.setValue(t5, s2)
// sm.setValue(t10, s1)
// sm.setValue(t15, s2)
// sm.setValue(t20, s1)
// 
// // var cmd : TimeVaryingMap[CmdState] = if sm.shift(1) = s1 && sm = s2 then GO else 
// //                                    ( if sm.shift(1) = s2 && sm = s1 then STOP else cmd.getValueEarlier(time) )
// 
// var cmd : TimeVaryingMap[CmdState]
// 
// var tr_s1_s2 : TimeVaryingMap[Bool] = sm.shift(1) = s1 && sm = s2
// req elaborates(null, E.class, tr_s1_s2)
// class E extends DurativeEvent {
//     cmd.setValue(startTime, GO)
// }
// 
// class CmdState
// val GO : CmdState
// val STOP : CmdState
