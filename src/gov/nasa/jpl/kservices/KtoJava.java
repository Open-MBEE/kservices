package gov.nasa.jpl.kservices;

import com.microsoft.z3.BoolExpr;
import gov.nasa.jpl.ae.event.*;
//import org.apache.commons.lang3.reflect.MethodUtils;

import gov.nasa.jpl.ae.util.CaptureStdoutStderr;
import gov.nasa.jpl.ae.util.ClassData;
import gov.nasa.jpl.ae.util.distributions.DistributionHelper;
import java.util.List;
import gov.nasa.jpl.mbee.util.*;
import japa.parser.*;
//import japa.parser.ASTHelper;
import japa.parser.ASTParser;
import japa.parser.ParseException;
import japa.parser.ast.CompilationUnit;
import japa.parser.ast.PackageDeclaration;
import japa.parser.ast.body.ClassOrInterfaceDeclaration;
import japa.parser.ast.body.ConstructorDeclaration;
import japa.parser.ast.body.FieldDeclaration;
import japa.parser.ast.body.MethodDeclaration;
import japa.parser.ast.body.ModifierSet;
import japa.parser.ast.body.TypeDeclaration;
import japa.parser.ast.body.VariableDeclarator;
import japa.parser.ast.body.VariableDeclaratorId;
import japa.parser.ast.expr.Expression;
import japa.parser.ast.expr.MethodCallExpr;
import japa.parser.ast.expr.NameExpr;
import japa.parser.ast.stmt.BlockStmt;
import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
import japa.parser.ast.stmt.Statement;
import japa.parser.ast.stmt.TryStmt;
import japa.parser.ast.type.ClassOrInterfaceType;
import japa.parser.ast.type.PrimitiveType;
import japa.parser.ast.type.Type;
import japa.parser.ast.type.VoidType;
import k.frontend.*;
import scala.Option;
import scala.Tuple2;
import scala.collection.JavaConversions;

import java.io.*;
import java.util.*;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


// Keep these for resolving class references.
import gov.nasa.jpl.ae.xml.EventXmlToJava;

import org.json.JSONArray;
import org.json.JSONObject;

// import gov.nasa.jpl.kservices.scala.AeKUtil;

import gov.nasa.jpl.ae.util.JavaToConstraintExpression;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

/*
 * Translates XML to executable Java classes for Analysis Engine behavior
 */

public class KtoJava {

    /**
     * The instantiation of a Durative event as the problem to solve and the solution.
     */
    public DurativeEvent mainEvent;

    protected boolean tryingToCompileAndLoadInPlace = true;

    protected String k;
    protected String packageName;
    protected Map<String, JavaToConstraintExpression> expressionTranslators;
    protected String smtOutput = null;
    protected HashMap<String, ArrayList<String>> smtTopObjects;
    protected HashMap<String, ArrayList<String>> smtExtraObjects;

    protected int constraintCounter;
    protected int expressionCounter;
    protected TypeChecker typeChecker;
    public boolean typeCheckSucceeded = false;
    protected Map<String, Model> models = new LinkedHashMap<String, Model>();
    protected ArrayList<Model> packageModels = new ArrayList<Model>();
    public final String globalName;
    protected final String autoGenerated;
    protected Set< EntityDecl > allClasses;
    protected Set< EntityDecl > topLevelClasses;
    protected Set< String > allClassNames;
    protected Set< String > topLevelClassNames;
    protected Set< String > instantiatedClassNames;
    protected Map< String, Set< String > > classToParentNames;

    public ArrayList<String> kFiles = new ArrayList<String>();
    protected ArrayList<String> javaFiles = new ArrayList<String>();

    static protected DistributionHelper dh = new DistributionHelper();


    public JSONObject json = new JSONObject();

    //boolean containmentTree = false;
    //boolean errorInfo = false;
    //boolean translate = false;
    protected boolean verbose = false;
    protected boolean processStdoutAndStderr = true;
    protected boolean allInitsAreConstraints = true;
    protected boolean smtSolved = false;

    //private ImmutableSet

    public KtoJava( String k, String pkgName, boolean translate, boolean processStdoutAndStderr ) {
        this.globalName = "Global";
        this.autoGenerated = "AutoGenerated";
        this.k = k;
        this.processStdoutAndStderr = processStdoutAndStderr;
        //if ( pkgName != null && !pkgName.equals( "" ) ) {
            this.packageName = pkgName;
        //} else {
        //    this.packageName = "";
        //}
        // Debug.turnOn();
        this.constraintCounter = 0;
        this.expressionCounter = 0;
        this.expressionTranslators = new LinkedHashMap<String, JavaToConstraintExpression>();
                //new JavaToConstraintExpression( packageName );

        // Clear out data from previous k parses.  The type checker is a singleton.
        if ( typeChecker != null ) typeChecker.reset();
        TypeChecker.reset();

        if ( verbose ) {
            System.out.println();
        }
        // Parse!
        Model m = getModelFromString();
        if ( m == null || m.decls() == null || m.decls().isEmpty() ) return;
//        if ( !modelHasDeclsOutsidePackages( m ) ) {
//            this.packageName = "";
//        } else {
//            if ( !Utils.isNullOrEmpty( m.packageName().get() ) ) {
//                this.packageName =  m.packageName().get();
//            } else if ( m.packages() != null && !m.packages().isEmpty() ) {
////                this.packageName = m.packageName().get();
////                if ( this.packageName == null ) {
//                    this.packageName = "";
////                }
//            }
//            // else use the package name assigned from the constructor argument.
//        }
        setModel(m);
        // Type check!
        typeCheckSucceeded = typeCheck();

        init( translate );
    }

    public static boolean modelHasDeclsOutsidePackages( Model model ) {
        if ( model == null ) return false;
        if ( model.decls() == null ) return false;
        Collection<TopDecl> declList = JavaConversions.asJavaCollection(model.decls());
        for ( TopDecl d : declList ) {
            if ( d instanceof PackageDecl ) continue;
            return true;
        }
        return false;
    }

    public void determineActualPackageName(Model m) {
        if ( m == null ) {
            Debug.error(true, false, "Warning! Trying to set model to null!");
            return;
        }
        boolean hasDecls = m.decls() != null && !m.decls().isEmpty();
        if ( !modelHasDeclsOutsidePackages( m ) ) {
            this.packageName = "";
        } else {
            scala.Option<String> x = scala.Option.apply(null);
            if ( m.packageName() != x && !Utils.isNullOrEmpty( m.packageName().get() ) ) {
                this.packageName =  m.packageName().get();
            } else if ( m.packages() != null && !m.packages().isEmpty() ) {
//                this.packageName = m.packageName().get();
//                if ( this.packageName == null ) {
                this.packageName = "";
//                }
            }
            // else use the package name assigned from the constructor argument.
        }

//        //if ( packageName == null ) packageName = "";
//        String packageName = this.packageName;
//        if ( m.packageName() != null && m.packageName().get() != null ) {
//            packageName = m.packageName().get();
//        }
//        if ( packageName == null ) packageName = "";
//        this.packageName = packageName;
        if ( this.packageName == null ) {
            this.packageName = "";
        }
    }

    public void setModel(Model m) {
        determineActualPackageName(m);
        models.put(this.packageName, m);
    }

    public void init(boolean translate) {
        // Collect declaration info
        this.topLevelClasses = getTopLevelClasses();
        this.allClasses = getAllClasses();
        this.allClassNames = new TreeSet< String >();
        this.topLevelClassNames = new TreeSet< String >();
        this.classToParentNames = new TreeMap< String, Set< String > >();
        // FIXME -- Why are we traversing lists that are guaranteed to be empty.  Should these be somwwhere else?
        for ( EntityDecl e : topLevelClasses ) {
            this.topLevelClassNames.add( e.fqName() );
        }
        for ( EntityDecl e : allClasses ) {
            this.allClassNames.add( e.fqName() );
            this.classToParentNames.put( e.fqName(),
                                         new TreeSet< String >( JavaConversions.asJavaCollection( e.getExtendingNames() ) ) );

        }
        for ( String e : allClassNames ) {
            getAllSuperClassNames( e );
        }

        this.instantiatedClassNames = new TreeSet< String >();
        //Debug.turnOn();
        buildNestingTable( getClassData().getNestedToEnclosingClassNames() );
        buildParamTable( getClassData().getParamTable() );
        buildMethodTable( getClassData().getMethodTable() );

        // Translate to Java
        if ( translate ) {
            translatePackage();
        }
    }

    public KtoJava( String k, String pkgName, boolean processStdoutAndStderr ) {
        this( k, pkgName, false, processStdoutAndStderr );
    }

    public JavaToConstraintExpression expressionTranslator() {
        return expressionTranslator(this.packageName);
    }
    public JavaToConstraintExpression expressionTranslator(String packageName) {
        JavaToConstraintExpression e = expressionTranslators.get(packageName);
        if ( e == null ) {
            e = new JavaToConstraintExpression( packageName );
            expressionTranslators.put(packageName, e);
        }
        return e;
    }

    public static Model findModelForPackageInModel(String packageName, Model model) {
        if ( packageName == null ) return null;
        if ( packageName.equals(model.packageName().get()) ) {
            return model;
        }
        for ( PackageDecl p : JavaConversions.asJavaCollection( model.packages() ) ) {
            if ( packageName.equals( p.name().toString() ) ) {
                return model;
            }
            if ( packageName.startsWith(p.name().toString()) ) {
                Model m = findModelForPackageInModel(packageName, p.model());
                if ( m != null ) return m;
            }
        }
        return null;
    }

    public Model model() {
        return model(this.packageName);
    }
    public Model model(String packageName) {
        Model m = models.get(packageName);
        if ( m == null && !packageName.equals(this.packageName)) {
            Model model = model(this.packageName);
            if ( model != null ) {
                m = findModelForPackageInModel(packageName, model);
                if ( m != null ) {
                    models.put(packageName, m);
                }
            }
        }
        return m;
    }

    public boolean runSMT() {
        smtSolved = false;
        if(typeCheckSucceeded){
            try {
                //             K2Z3.solveSMT(this.model, this.model.toSMT(), true);
                BoolExpr boolExp = K2Z3.ctx().parseSMTLIB2String(this.model().toSMT(), null, null, null, null);
                com.microsoft.z3.Model z3Model = K2Z3.SolveExp(boolExp, this.model().toSMT());
                this.smtSolved = z3Model != null && com.microsoft.z3.Status.SATISFIABLE == K2Z3.solver().check();
                CaptureStdoutStderr stdoutStderr = new CaptureStdoutStderr() {
                    @Override public Object run() {
                        K2Z3.PrintModel(KtoJava.this.model());
                        return null;
                    }
                };

                this.smtOutput = stdoutStderr.baosOut.toString();
////                System.out.println(z3Model.toString());
                System.out.println(this.smtOutput);
                this.json.put("solveOutput", this.smtOutput);
            } catch (Throwable e) {
                System.out.println(e.getMessage());
            }
        }
        return smtSolved;
    }

    public Model getModelFromString() {
        if ( !processStdoutAndStderr ) {
            Model m = Frontend.getModelFromString(this.k);
            setModel(m);
        } else {
            CaptureStdoutStderr c = new CaptureStdoutStderr() {
                @Override
                public Object run() {
                    Model m = Frontend.getModelFromString(KtoJava.this.k);
                    setModel(m);
                    return null;
                }
            };
            String err = c.baosErr.toString();
            String out = c.baosOut.toString();
            String[] parseErrors = err.split("\n");
            JSONArray jarr = json.has("parseErrors") ? json.getJSONArray("parseErrors") : new JSONArray();
            for ( String str : parseErrors ) {
                jarr.put(str);
            }
            //jarr.put(Utils.arrayAsList(parseErrors));  // This deosn't work!
            json.put("parseErrors", jarr);
            //if ( verbose ) {
                System.err.println(err);
                System.out.println(out);
                System.out.println();
            //}
        }
        return this.model();
    }


    public boolean typeCheckForReal() {
        try {
            if ( typeChecker != null ) typeChecker.reset();
            TypeChecker.reset();
            typeChecker = new TypeChecker(this.model());
            typeCheckSucceeded = true;
        } catch (Throwable e) {
            typeCheckSucceeded = false;
            System.err.println("Input did not Type Check");
            e.printStackTrace();
        }
        return typeCheckSucceeded;
    }
    public boolean typeCheck() {
        if (!processStdoutAndStderr) {
            typeCheckSucceeded = typeCheckForReal();
        } else {
            CaptureStdoutStderr c = new CaptureStdoutStderr() {
                @Override
                public Object run() {
                    return typeCheckForReal();
                }
            };
            String err = c.baosErr.toString();
            String out = c.baosOut.toString();
            String[] typeCheckErrors = err.split("\n");
            JSONArray jarr = json.has("typeCheckErrors") ? json.getJSONArray("typeCheckErrors") : new JSONArray();
            for ( String str : typeCheckErrors ) {
                jarr.put(str);
            }
            //jarr.put(Utils.arrayAsList(typeCheckErrors));  // This deosn't work!
            json.put("typeCheckErrors", jarr);
            //if ( verbose ) {
                System.err.println(err);
                System.out.println(out);
            //}
        }
        return typeCheckSucceeded;
    }


    public Set< EntityDecl > getTopLevelClasses() {
        if ( Utils.isNullOrEmpty(topLevelClasses) ) {
            topLevelClasses = getTopLevelClasses(model());
        }
        return topLevelClasses;
    }

    public static Set< EntityDecl > getTopLevelClasses( Model model ) {
        Set< EntityDecl > topLevelClasses = new LinkedHashSet<EntityDecl>(
                JavaConversions.asJavaCollection(
                        Frontend.getEntitiesFromModel(model)));
        return topLevelClasses;
    }

    public Set< EntityDecl > getAllClasses() {
        return getAllClasses( model() );
    }
    public static Set< EntityDecl > getAllClasses(Model model) {
        Set< EntityDecl > allEntities = new LinkedHashSet< EntityDecl >();
        if ( model == null ) return allEntities;
        Set<EntityDecl> classes = getTopLevelClasses(model);
        if ( Utils.isNullOrEmpty(classes) ) return allEntities;
        Deque< EntityDecl > entitiesToGo =
                new ArrayDeque< EntityDecl >( classes );
        for(EntityDecl entity : entitiesToGo) {
            entity.qualifyTopLevelName();
        }

        EntityDecl entity;
        while ( !entitiesToGo.isEmpty() ) {
            entity = entitiesToGo.pop();
            entity.qualifyMemberNames();
            allEntities.add( entity );
            entitiesToGo.addAll( JavaConversions.asJavaCollection( entity.getEntityDecls() ) );
        }
        Collection<PackageDecl> pkgs = JavaConversions.asJavaCollection( model.packages() );
        if ( pkgs == null ) return allEntities;
        for ( PackageDecl p : pkgs ) {
            Model m = p.model();
            Set<EntityDecl> moreClasses = getAllClasses(m);
            if ( !Utils.isNullOrEmpty(moreClasses) ) {
                allEntities.addAll( moreClasses );
            }
        }
        return allEntities;
    }

    public void getAllSuperClassNames( String entityName ) {
        Set< String > extendingList = classToParentNames.get( entityName );
        if ( extendingList != null ) {
            for ( String e : extendingList ) {
                getAllSuperClassNames( e );
                Set< String > toAdd = classToParentNames.get( e );
                if ( toAdd != null ) {
                    extendingList.addAll( toAdd );
                }

            }
        }

    }

    /**
     * Given the simple name of the type of a parameter and the class in which it was declared, finds the fully qualified name
     * of the type based on scoping rules.
     * @param type (simple) name of the type
     * @param containingClass (fully qualified) name of the class containing the parameter
     * @return (fully qualified) name of the type, null if no matching name was found
     */
    public String findQualifiedTypeInScope(String type, String containingClass) {
        // start in deepest scope
        String candidate = containingClass + "." + type;
        //find the last period that appears before the one directly before type
        int lastPeriod = candidate.lastIndexOf('.', candidate.length() - type.length() - 2);


        // while there is still a period in the name (ignores periods in type). Once there are no periods, we have reached "Global"
        while(lastPeriod >= 0) {
            if(this.allClassNames.contains(candidate)) {
                return candidate;
            }

            // cut off everything after the last level of scope and add the type back on
            // i.e. Global.A.B.C.type becomes Global.A.B.type
//            int cutPoint = candidate.lastIndexOf('.', lastPeriod - 1);
//            if(cutPoint < 0) break; // if there are no more periods before the last one - reached "Global"

            candidate = candidate.substring(0, lastPeriod) + "." + type; //reattach the type
            lastPeriod = candidate.lastIndexOf('.', candidate.length() - type.length() - 2);
        }

        if(this.allClassNames.contains(candidate)) {
            return candidate;
        }

        return null;
    }

    public void buildNestingTable( Map< String, String > nestingTable ) {
        // true nested classes:
        for ( EntityDecl entity : this.allClasses ) {
            for ( EntityDecl innerEntity : JavaConversions.asJavaCollection( entity.getEntityDecls() ) ) {
                nestingTable.put( innerEntity.fqName(), entity.fqName() );
            }
        }

        for ( EntityDecl entity : this.allClasses ) {
            if ( !nestingTable.containsKey( entity.fqName() ) ) {
                nestingTable.put( entity.fqName(), globalName );
            }
        }
    }

    public void
           buildParamTable( Map< String, Map< String, ClassData.Param > > paramTable ) {
        Map< String, ClassData.Param > params =
                new TreeMap< String, ClassData.Param >();
        ClassData.Param param;
        addGlobalParams( paramTable );

        // get params from all the classes
        for ( EntityDecl entity : this.allClasses ) { // pass 1
            String entityName = entity.fqName();
            params = new TreeMap< String, ClassData.Param >();

            //go through all the parameters declared in a class
            ArrayList< PropertyDecl > propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDeclsNoIgnore() ) );
            for ( PropertyDecl p : propertyList ) {
                param = makeParam( p, entity );
                if (param.scope == null) param.scope = entityName;

                String type = p.ty().toJavaString();
                String fqType = findQualifiedTypeInScope(type, entityName); // get the fully qualified type name

                if (fqType != null) {
                    this.instantiatedClassNames.add( fqType );
                }

                params.put( p.name(), param );
            }

            // add functions to the parameter table
            ArrayList< FunDecl > funList =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
            for ( FunDecl funDecl : funList ) {
                Collection<Param> prms = JavaConversions.asJavaCollection(funDecl.params());
                List< Param > funParams = new ArrayList< Param >( prms );
                for ( Param p : funParams ) {
                    param = new ClassData.Param( p.name(),
                                                 JavaToConstraintExpression.typeToClass( p.ty()
                                                                                          .toJavaString() ),
                                                 null, entityName );
                    params.put( p.name(), param );
                }

            }

            paramTable.put( entityName, params );

        }

        // Add inherited parameters.
        for ( EntityDecl entity : this.allClasses ) { // pass 2
            String entityName = entity.fqName();
            params = paramTable.get( entityName );

            Set< String > extendingList =
                    classToParentNames.get( entity.fqName() );
            for ( String e : extendingList ) {
                if ( "Event".equals(e) || "DurativeEvent".equals(e) ) {
                    EventXmlToJava.isEventMap.put(entityName, true);
                }

                Map< String, ClassData.Param > otherParams =
                        paramTable.get( getClassName( e ) );
                if ( otherParams != null ) {
                    params.putAll( otherParams );
                }

            }

            if ( !EventXmlToJava.isEventMap.containsKey(entityName) ) {
                Set<String> pNames = classToParentNames.get(entityName);
                if ( pNames != null && (pNames.contains("Event") || pNames.contains("DurativeEvent")) ) {
                    EventXmlToJava.isEventMap.put(entityName, true);
                }
            }
        }
    }

    public void
           addGlobalParams( Map< String, Map< String, ClassData.Param > > paramTable ) {
        ClassData.Param param;
        Map< String, ClassData.Param > params =
                new TreeMap< String, ClassData.Param >();
        List< PropertyDecl > topLevelProperties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
        List< FunDecl > topLevelFunctions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );

        for ( PropertyDecl p : topLevelProperties ) {
            param = makeParam( p, null );
            param.scope = globalName;
            String type = p.ty().toJavaString();
            String fqType = globalName + "." + type; // at top level, types are all going to be prefixed with globalName

            if ( this.allClassNames.contains( fqType ) ) {
                this.instantiatedClassNames.add( fqType );
            }
            params.put( p.name(), param );
        }

        for ( FunDecl funDecl : topLevelFunctions ) {
            List< Param > funParams =
                    new ArrayList< Param >( JavaConversions.asJavaCollection( funDecl.params() ) );
            for ( Param p : funParams ) {
                param = new ClassData.Param( p.name(),
                                             JavaToConstraintExpression.typeToClass( p.ty()
                                                                                      .toJavaString() ),
                                             null, globalName );
                params.put( p.name(), param );
            }
        }

        paramTable.put( globalName, params );

    }

    public void
           buildMethodTable( Map< String, Map< String, Set< MethodDeclaration > > > methodTable ) {
        addGlobalMethods( methodTable );
        for ( EntityDecl entity : this.allClasses ) {
            String entityName = entity.fqName();

            Map< String, Set< MethodDeclaration > > classMethods =
                    methodTable.get( entityName );

            if ( classMethods == null ) {
                classMethods =
                        new TreeMap< String, Set< MethodDeclaration > >();
                methodTable.put( entityName, classMethods );
            }
            Collection< MethodDeclaration > methodCollection =
                    getMethods( entity );

            for ( MethodDeclaration methodDecl : methodCollection ) {
                Set< MethodDeclaration > methodSet =
                        classMethods.get( methodDecl.getName() );
                if ( methodSet == null ) {
                    methodSet =
                            new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
                    classMethods.put( methodDecl.getName(), methodSet );
                }
                methodSet.add( methodDecl );
            }

        }
    }

    public void
           addGlobalMethods( Map< String, Map< String, Set< MethodDeclaration > > > methodTable ) {
        List< FunDecl > topLevelFunctions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        Map< String, Set< MethodDeclaration > > classMethods =
                new TreeMap< String, Set< MethodDeclaration > >();
        methodTable.put( globalName, classMethods );
        Collection< MethodDeclaration > methodCollection = getMethods( null );
        for ( MethodDeclaration methodDecl : methodCollection ) {
            Set< MethodDeclaration > methodSet =
                    classMethods.get( methodDecl.getName() );
            if ( methodSet == null ) {
                methodSet =
                        new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
                classMethods.put( methodDecl.getName(), methodSet );
            }
            methodSet.add( methodDecl );
        }

    }

    // Delete this!  We're looking for a call not a declaration!
//    public boolean isElaboratesMethod( MethodDeclaration m ) {
//        if ( m == null ) return false;
//        if ( !m.getName().equals("elaborates") ) return false;
//        if ( m.getParameters() == null ) return false;
//        if ( m.getParameters().size() < 2 ) return false;
//        if ( m.)
//        return true;
//    }

    public Collection< MethodDeclaration > getMethods( EntityDecl entity ) {
        ArrayList< MethodDeclaration > methodDeclarations =
                new ArrayList< MethodDeclaration >();
        ArrayList< FunDecl > functions;
        if ( entity != null ) {
            functions =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
        } else {
            functions =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        }

        for ( FunDecl funDecl : functions ) {
            MethodDeclaration methodDecl = makeMethodDecl( funDecl );
            if ( methodDecl != null ) {
                methodDeclarations.add( methodDecl );
            }
        }
        return methodDeclarations;

    }

    protected <T> T get(Option<T> o) {
        if ( o == null || o.isEmpty() ) {
            return null;
        }
        return o.get();
    }

    public MethodDeclaration makeMethodDecl( FunDecl funDecl ) {
        MethodDeclaration methodDecl = new MethodDeclaration();
        Option<k.frontend.Type> ty = funDecl.ty();
        k.frontend.Type tyg = get(ty);
        String typeString = (tyg == null ? null :
                JavaToConstraintExpression.typeToClass(tyg
                        .toJavaString()));
        methodDecl.setType( new ClassOrInterfaceType( "Expression<" + typeString
                                                      + ">" ) );
        methodDecl.setModifiers( 1 );
        methodDecl.setName( funDecl.ident() );
        List< Param > funParams =
                new ArrayList< Param >( JavaConversions.asJavaCollection( funDecl.params() ) );
        List< japa.parser.ast.body.Parameter > params =
                new ArrayList< japa.parser.ast.body.Parameter >();
        japa.parser.ast.body.Parameter param;
        for ( Param p : funParams ) {
            param = ASTHelper.createParameter( makeType( p.ty().toJavaString() ),
                                               p.name() );
            params.add( param );
        }
        methodDecl.setParameters( params );
        if ( funDecl.body().isEmpty() ) { // in the case where a method is
            // declared but not defined, not sure
            // if this is the best thing to do
            return null;
        }
        methodDecl.setThrows( Arrays.asList( new NameExpr( "Exception" ) ) );

        return methodDecl;
    }

    public Type makeType( String typeString ) {
        Type type;
        switch ( typeString ) {
            case "Int":
                type = new PrimitiveType( PrimitiveType.Primitive.Int );
                break;
            case "Bool":
                type = new PrimitiveType( PrimitiveType.Primitive.Boolean );
                break;
            case "Real":
                type = new PrimitiveType( PrimitiveType.Primitive.Double );
                break;
            default:
                type = new ClassOrInterfaceType( typeString );
        }
        return type;

    }

    public Boolean isPrimitive( String typeString ) {
        return typeString.equals( "Int" ) || typeString.equals( "Bool" )
               || typeString.equals( "Real" ) || typeString.equals( "String" );
    }

    public boolean isConstructorDecl( PropertyDecl p ) {
        String type =
                JavaToConstraintExpression.typeToClass( p.ty().toJavaString() );
        String value = p.expr().get().toJavaString();
        if ( value.matches("[_A-Za-z0-9.]*" + type + "[(].*") ) {
        //if ( value.startsWith( type + "(" ) ) {
            return true;
        }
        return false;
    }
    
    public String makeExpressionString(Exp exp) {
        if (exp == null) {
            return null;
        }
        checkForSetupConfig(exp);
        return exp.toJavaString();
    }

    protected String getArgString( Exp exp ) {
        if ( exp instanceof StringLiteral ) {
            return ((StringLiteral)exp).s();
        }
        if ( exp instanceof DateLiteral ) {
            return exp.toString();
        }
        return exp.toJavaString();
    }

    protected Long getLong( Exp exp ) {
        if ( exp instanceof IntegerLiteral ) {
            return ((IntegerLiteral)exp).i();
        }
        String s = getArgString(exp);
        if ( s != null ) {
            try {
                return Long.valueOf(s);
            } catch (Throwable t) {}
        }
        return null;
    }

    static HashSet<String> setupMethodNames = new HashSet<String>() {
        {
            add("setEpoch");
            add("setUnits");
            add("setHorizon");
            add("setHorizonDuration");
        }
    };

    protected void checkForSetupConfig(Exp exp) {
        if ( !processStdoutAndStderr ) {
            checkForSetupConfigImpl(exp);
        } else {
            CaptureStdoutStderr c = new CaptureStdoutStderr() {
                @Override public Object run() {
                    checkForSetupConfigImpl(exp);
                    return null;
                }
            };
        }
    }
    protected void checkForSetupConfigImpl(Exp exp) {
        if ( exp == null ) return;
        if ( exp instanceof FunApplExp ) {
            FunApplExp fae = (FunApplExp)exp;
            if ( fae.name() != null ) {
                if (setupMethodNames.contains(fae.name())) {
                    if ( fae.args() != null ) {
                        Collection<Argument> coll =
                                JavaConversions.asJavaCollection(fae.args());
                        Exp firstArgExp = null;
                        for ( Argument a : coll ) {
                            if ( a instanceof NamedArgument ) {
                                firstArgExp = ((NamedArgument)a).exp();
                            } else if ( a instanceof PositionalArgument){
                                firstArgExp = ((PositionalArgument)a).exp();
                            } else {
                                Debug.error(true, "Say what?!!");
                            }
                            if ( firstArgExp != null ) {
                                try {
                                    if ( fae.name().equals("setEpoch") ) {
                                        String s = getArgString(firstArgExp);
                                        if ( s != null ) {
                                            Timepoint.setEpoch(s);
                                        }
                                    } else if ( fae.name().equals("setUnits") ) {
                                        String s = getArgString(firstArgExp);
                                        if ( s != null ) {
                                            Timepoint.setUnits(s);
                                        }
                                    } else if ( fae.name().equals("setHorizon") ) {
                                        //JavaToConstraintExpression.parseExpression( firstArgExp.toJavaString() );
                                        String s = getArgString(firstArgExp);
                                        if ( s != null ) {
                                            Timepoint.setHorizon(s);
                                        }
                                    } else if ( fae.name().equals("setHorizonDuration") ) {
                                        Long lng = getLong(firstArgExp);
                                        if ( lng != null ) {
                                            Timepoint.setHorizonDuration(lng);
                                        }
                                    }
                                    return;
                                } catch (Throwable t) {}
                            }
                        }
                    }
                }
            }
        }
    }

    public ClassData.Param makeParam( PropertyDecl p, EntityDecl e ) {
        String name = p.name();
        String typeOld =
                JavaToConstraintExpression.typeToClass(p.ty().toJavaString());

        String type = typeOld;
//        if ( e != null ) {
//            type = getClassName( type );
//        }
//        if ( ( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
//               || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
//               || typeOld.equals( "String" ) ) ) {
//            type = typeOld;
//        }
        String value;
        if ( p.expr().isEmpty() ) {
            value = "null";
            if (!ClassUtils.getNonPrimitives().keySet().contains(typeOld) ) {
//            if ( !( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
//                    || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
//                    || typeOld.equals( "String" ) ) ) {
                String clsString = "(Class)null";
                if ( isStateVariableType( typeOld ) ) {
                    if ( type.startsWith("TimeVarying") && type.contains("<") || (type.contains("[") && type.contains("]") ) ) {
                        String t2 = type.replaceAll("\\[", "<").replaceAll("\\]", ">");
                        String typeParameter = ClassUtils.parameterPartOfName( t2, false );
                        if ( !Utils.isNullOrEmpty(typeParameter) ) {
                            clsString = typeParameter + ".class";
                        }
                    }
                    if ( type.equals( "Consumable" ) ) {
                        value =  "new " + type + "(\"" + p.name() + "\")";
                    } else {
                        value = "new " + type + "(\"" + p.name() + "\", (String)null, null, " + clsString + ")";
                    }
                } else {
                    value = "new " + type + "()";
                }
            }
        } else {
            //if (p.expr().canBeNull())
            if ( isConstructorDecl( p ) ) {
                //value = "new " + value;
                value = "null";
            } else {
                value = makeExpressionString(p.expr().get());
                //if ( isConstructorDecl( p ) ) {
                //    value = "new " + value;
                //}
            }
        }
        String entityName = e == null ? null : getClassName(e);
        return new ClassData.Param( name, type, value, entityName );
    }

    public ClassData.Param makeParam( PropertyDecl p, EntityDecl e,
                                      Boolean nullValue ) {
        if ( !nullValue ) {
            return makeParam( p, e );
        }

        String name = p.name();
        String typeOld =
                JavaToConstraintExpression.typeToClass( p.ty().toJavaString() );
        String type = typeOld;
        if ( e != null ) {
            // type = getClassName( type );
        }
        if ( ( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
               || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
               || typeOld.equals( "String" ) ) ) {
            type = typeOld;
        }
        String value;
        if ( p.expr().isEmpty() ) {
            value = "null";
            if ( !( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
                    || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
                    || typeOld.equals( "String" ) ) ) {
                value = "new " + type + "()";
            }
        } else {
            value = "null";

        }
        return new ClassData.Param( name, type, value, getClassName( e ) );

    }

    // REVIEW -- Does anything call this?
    public void translateExpression() {
        getClassData().setCurrentClass( "Main" );
        initClassCompilationUnit( getClassData().getCurrentClass() );

        ClassOrInterfaceDeclaration newClassDecl =
                new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                 getClassData().getCurrentClass() );
        ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                      newClassDecl );

        int mods = ModifierSet.PUBLIC | ModifierSet.STATIC;

        MethodDeclaration mainMethodDecl =
                new MethodDeclaration( mods, new VoidType(), "main" );
        BlockStmt mainBody = new BlockStmt();
        mainMethodDecl.setBody( mainBody );

        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt ctorBody = new BlockStmt();
        ctor.setBlock( ctorBody );

        Type type = ASTHelper.createReferenceType( "String", 1 );
        VariableDeclaratorId id = new VariableDeclaratorId( "args" );
        japa.parser.ast.body.Parameter parameter =
                new japa.parser.ast.body.Parameter( type, id );

        ASTHelper.addParameter( mainMethodDecl, parameter );
        ASTHelper.addMember( newClassDecl, mainMethodDecl );

        StringBuffer stmtsMain = new StringBuffer();

        List< Expression > args = new ArrayList< Expression >();
        Expression expr = expressionTranslator().parseExpression( this.k );
        String aeString = expressionTranslator().astToAeExpr( expr, null, true,
                                                            true, false, true, true );
        stmtsMain.append( "Object value = " + aeString + ";" );
        stmtsMain.append( "System.out.println( value );" );
        ASTHelper.addStmt( ctorBody,
                           new ExplicitConstructorInvocationStmt( false, null,
                                                                  args ) );

        addImport( "gov.nasa.jpl.ae.event.Expression" );

        addStatements( mainBody, stmtsMain.toString() );

        String tryCatchString = "try{\n" + ";\n" + "} catch ( Exception e ) {\n"
                                + "  // TODO Auto-generated catch block\n"
                                + "  e.printStackTrace();\n" + "}\n";

        List< Statement > stmts = new ArrayList< Statement >();
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );

        TryStmt tryStmt = null;

        ASTParser parser = new ASTParser( new StringReader( tryCatchString ) );
        try {
            tryStmt = parser.TryStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
            return;
        }
        tryStmt.setTryBlock( mainBody );
        stmts.add( tryStmt );
        BlockStmt newBody = new BlockStmt( stmts );
        mainMethodDecl.setBody( newBody );

    }


    public void translatePackage() {
        // Translate current package
        translatePackage(this.packageName);
    }
    public void translatePackage( PackageDecl p ) {
        if ( p != null ) {
            Model model = p.model();
            String pName = p.name().toString();
            if ( pName == null ) pName = "";
            models.put( pName, model );
            translatePackage( pName );
        }
    }
    public void translatePackage( String packageName ) {
        this.packageName = packageName;

        // Save name
        String originalPackageName = packageName;
        
        // Initialize translation data for package
        Model m = model();
        if ( m == null ) return;
        JavaToConstraintExpression xlator = expressionTranslator();
        init( false );

        translateClasses();

        // recursively translate subpackages
        scala.collection.immutable.List<PackageDecl> pkgs = m.packages();
        if ( pkgs == null ) return;
        Collection< PackageDecl > packages = JavaConversions.asJavaCollection( pkgs );
        try {
            for (PackageDecl p : packages) {
                translatePackage(p);
            }
        } catch ( Throwable t ) {
            t.printStackTrace();
        } finally {
            //model = originalModel;
            packageName = originalPackageName;
        }
    }

    public void translateClasses() {
        // Translate class (and other?) declarations.
        processClassDeclarations( true );
        processClassDeclarations( false );
        addConstructors();
        processExecutionEvent();
    }


        /**
         * @return the expressionTranslator
         */
    public JavaToConstraintExpression getExpressionTranslator() {
        return expressionTranslator();
    }

    public ClassData getClassData() {
        JavaToConstraintExpression t = getExpressionTranslator();
        if ( Debug.errorOnNull( "Trying to get classData from null translator!",
                                t ) ) {
            return null;
        }
        return t.getClassData();
    }

    private void processClassDeclarations( boolean justClassDeclarations ) {
        processClassDeclarations( null, justClassDeclarations );
    }

    private void processClassDeclarations( EntityDecl entity,
                                           boolean justClassDeclarations ) {
        ClassOrInterfaceDeclaration classDecl;
        if ( justClassDeclarations ) {
            if ( entity == null ) {
                getClassData().setCurrentCompilationUnit( initClassCompilationUnit( globalName ) );
            }
            classDecl =
                    processClassDeclaration( entity, justClassDeclarations );
            ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                          classDecl );
        } else {
            processClassDeclaration( entity, justClassDeclarations );
        }
    }

    public String getClassName( EntityDecl entity ) {
        if ( entity == null ) {
            return globalName;
        } else {
            return getClassName( entity.ident() );
        }
    }

    public String getClassName( String entityName ) {
        if ( entityName != null ) {
            String className = entityName;
            entityName = getClassData().getNestedToEnclosingClassNames()
                                       .get( entityName );
            while ( entityName != null ) {
                className = entityName + "." + className;
                entityName = getClassData().getNestedToEnclosingClassNames()
                                           .get( entityName );
            }
            return className;
        } else {
            return globalName;
        }
    }

    public ClassOrInterfaceDeclaration
           processClassDeclaration( EntityDecl entity,
                                    boolean justClassDeclarations ) {

        Collection< EntityDecl > innerEntities;
        //Collection< PackageDecl > packages = JavaConversions.asJavaCollection( model.packages() );
        String enclosingIdent;
        Collection< ClassOrInterfaceDeclaration > innerClassDecls =
                new ArrayList< ClassOrInterfaceDeclaration >();

        if ( entity == null ) {
            innerEntities = this.topLevelClasses;
            enclosingIdent = globalName;
        } else {
            innerEntities =
                    JavaConversions.asJavaCollection( entity.getEntityDecls() );
            enclosingIdent = entity.fqName();
        }

        for ( EntityDecl innerEntity : innerEntities ) {
            innerClassDecls.add( processClassDeclaration( innerEntity,
                                                          justClassDeclarations ) );
        }

        String currentClass = entity == null ? "Global" : entity.fqName();

        getClassData().setCurrentClass( currentClass );

        ClassOrInterfaceDeclaration newClassDecl = null;

        if ( justClassDeclarations ) {
            newClassDecl =
                    new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                     ClassUtils.simpleName( currentClass ) );

            getSuperClasses( entity, newClassDecl );
            getImports();

            createDefaultConstructor( newClassDecl );
        } else {
            // getClassData().setCurrentCompilationUnit(
            // getClassData().getClasses()
            // .get( currentClass ) );
            newClassDecl = getClassData().getClassDeclaration( currentClass ); // need
                                                                               // to
                                                                               // fix
            setMethodBodies( entity );
            createMembers( newClassDecl, entity );
        }

        if ( justClassDeclarations ) {
            for ( ClassOrInterfaceDeclaration innerClassDecl : innerClassDecls ) {
                ASTHelper.addMember( newClassDecl, innerClassDecl );
            }
        }

        return newClassDecl;

    }

    public void setMethodBodies( EntityDecl entity ) {
        List< FunDecl > funDecls;
        Map< String, Set< MethodDeclaration > > classMethods;
        if ( entity == null ) {
            classMethods = getClassData().getMethodTable().get( globalName );
            funDecls =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        } else {
            String entityName = entity.fqName();
            classMethods = getClassData().getMethodTable().get( entityName );
            funDecls =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
        }

        for ( FunDecl funDecl : funDecls ) {
            Set< MethodDeclaration > methodSet =
                    classMethods.get( funDecl.ident() );
            if ( methodSet != null ) {
                for ( MethodDeclaration methodDecl : methodSet ) {
                    BlockStmt body = new BlockStmt();
                    Option<k.frontend.Type> ty = funDecl.ty();
                    k.frontend.Type tyg = get(ty);

                    String typeString = (tyg == null ? null : tyg.toJavaString());
                    if ( !funDecl.body().isEmpty() ) {
                        Expression expr =
                                expressionTranslator().parseExpression( ( (ExpressionDecl)funDecl.body()
                                                                                               .apply( 0 ) ).exp()
                                                                                                            .toJavaString() );
                        String aeString =
                                expressionTranslator().astToAeExpr( expr,
                                                                  typeString,
                                                                  true, true,
                                                                  false,
                                                                  true, false );
                        addStatements( body, "return " + aeString + ";" );

                        methodDecl.setBody( body );
                    }
                }
            }

        }

    }
//        addDependency(startTime, new Expression<Long>(0L));
//        addDependency(duration, new Expression<Long>(Timepoint.getHorizonDuration()));
    protected void createDefaultConstructor( TypeDeclaration newClassDecl ) {
        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt block = new BlockStmt();
        ASTHelper.addStmt( block, new ExplicitConstructorInvocationStmt() );
        ctor.setBlock( block );
        ASTHelper.addStmt( block,
                new MethodCallExpr( null,
                        "init" + newClassDecl.getName()
                                + "Custom" ) );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Members" ) );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Collections" ) );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Dependencies" ) );
//        ASTHelper.addStmt( block,
//                           new MethodCallExpr( null,
//                                                "setAllConstraintsToStale"));

    }

    protected void getSuperClasses( EntityDecl entity,
                                    ClassOrInterfaceDeclaration newClassDecl ) {
        if ( entity == null ) {
            addExtends( newClassDecl, "DurativeEvent" );
            return;
        }
        List< ClassOrInterfaceType > extendsList = getInheritsFrom( entity );
        if ( !Utils.isNullOrEmpty( extendsList ) ) {
            newClassDecl.setExtends( extendsList );
        }
        if ( Utils.isNullOrEmpty( newClassDecl.getExtends() ) ) {
            addExtends( newClassDecl, "ParameterListenerImpl" );
        }
    }

    public List< ClassOrInterfaceType > getInheritsFrom( EntityDecl entity ) {

        // Need to figure out how to do multiple extends TODO
        // List< String > extendsStringList =
        // new ArrayList< String >( JavaConversions.asJavaCollection(
        // TypeChecker.getSuperClasses( entity.ident() ) ) );
        // List< ClassOrInterfaceType > extendsList =
        // new ArrayList< ClassOrInterfaceType >();
        // for ( String e : extendsStringList ) {
        // ClassOrInterfaceType c = new ClassOrInterfaceType( e );
        // extendsList.add( c );
        // }
        // return extendsList;
        // only do one for now
        List< k.frontend.Type > types =
                new ArrayList< k.frontend.Type >( JavaConversions.asJavaCollection( entity.extending() ) );
        if ( types.isEmpty() ) {
            return new ArrayList< ClassOrInterfaceType >();
        }
        k.frontend.Type type =
                new ArrayList< k.frontend.Type >( JavaConversions.asJavaCollection( entity.extending() ) ).get( 0 );
        return Arrays.asList( new ClassOrInterfaceType( type.toString() ) );
    }

    // right now assumes imports are java imports
    protected void getImports() {
        List< ImportDecl > imports =
                new ArrayList< ImportDecl >( JavaConversions.asJavaCollection( model().imports() ) );
        for ( ImportDecl imp : imports ) {
            addImport( imp.toStringNoImport() );
        }
    }
    // TODO

    public Set< MethodDeclaration > getMethodsForClass( String className ) {
        Map< String, Set< MethodDeclaration > > classMethods =
                getClassData().getMethodTable().get( className );
        if ( classMethods == null ) return ClassData.emptyMethodDeclarationSet;
        Set< MethodDeclaration > methodsForClass =
                new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
        for ( Set< MethodDeclaration > methodsByName : classMethods.values() ) {
            methodsForClass.addAll( methodsByName );
        }
        return methodsForClass;
    }

    protected void createMembers( TypeDeclaration newClassDecl,
                                  EntityDecl entity ) {

        Collection< MethodDeclaration > methods =
                getMethodsForClass( getClassData().getCurrentClass() );
        for ( MethodDeclaration methodDecl : methods ) {

            ASTHelper.addMember( newClassDecl, methodDecl );
        }

        MethodDeclaration initCustom =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                        + "Custom" );

        MethodDeclaration initMembers =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Members" );

        MethodDeclaration initElaborations =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Elaborations" );

        MethodDeclaration initDependencies =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Dependencies" );
        addStatements( initElaborations.getBody(),
                       "init" + newClassDecl.getName() + "Dependencies();" );

        List< FieldDeclaration > members = new ArrayList< FieldDeclaration >();
        Collection< FieldDeclaration > parameters =
                getParameters( entity, initMembers );
        Collection< FieldDeclaration > constraints =
                getConstraints( entity, initMembers );
        createEnclosingInstanceStatment( entity,initMembers );

        ArrayList<Pair<String, FieldDeclaration>> effects = null;
        effects = getEffects( entity, initMembers, false);  // TODO -- should deep be true?
        Collection< FieldDeclaration > elaborations = null;
        //elaborations = getElaborations( entity, initElaborations, false );

        
        parameters.addAll( getExpressions( entity, initMembers ) );

        members.addAll( parameters );
        members.addAll( constraints );
        for ( Pair< String, FieldDeclaration > p : effects ) {
            members.add( p.second );
        }
        if ( elaborations != null ) members.addAll( elaborations );

        addTryCatchToInitMembers( initMembers );
        

        MethodDeclaration initCollections =
                createInitCollectionsMethod( "init" + newClassDecl.getName()
                                             + "Collections", parameters, constraints, effects );

        // Add fields and methods to class declaration.
        for ( FieldDeclaration f : members ) {
            ASTHelper.addMember( newClassDecl, f );
        }
        ASTHelper.addMember( newClassDecl, initCustom );
        ASTHelper.addMember( newClassDecl, initMembers );
        ASTHelper.addMember( newClassDecl, initCollections );
        ASTHelper.addMember( newClassDecl, initDependencies );
        ASTHelper.addMember( newClassDecl, initElaborations );

    }

    public ArrayList< FieldDeclaration >
           getParameters( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > parameters =
                new ArrayList< FieldDeclaration >();
        ArrayList< PropertyDecl > propertyList;
        FieldDeclaration f;
        if ( entity == null ) {
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
            // TODO: improve scope resolution and turn this back into
            // allClassNames version
            // for ( String className : allClassNames ) {
            for ( String className : topLevelClassNames ) {
                if ( !instantiatedClassNames.contains( className ) ) {
                    ClassData.Param p =
                            new ClassData.Param( autoGenerated + className,
                                                 className, null, null );
                    f = createParameterField( p, initMembers );
                    if ( f != null ) {
                        parameters.add( f );
                    }
                }
            }
        } else {
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDeclsNoIgnore() ) );
        }

        for ( PropertyDecl property : propertyList ) {
            ClassData.Param p = makeParam( property, entity );
            if (p.scope == null && entity != null ) p.scope = getClassName(entity);
            if ( initializingNull( property ) ) {
                p.value = "null";
            }
            f = createParameterField( p, initMembers );
            if ( f != null ) {
                parameters.add( f );
            }

        }

        return parameters;
    }

    protected boolean initializingNull(PropertyDecl propertDecl) {
        Exp exp = get(propertDecl.expr());
        if ( isEvent( propertDecl.ty().toJavaString() ) ) {
            return true;
        }
        if ( hasElaboration( exp ) ) {
            return true;
        }
        return false;
    }

    public ArrayList< FieldDeclaration >
           getExpressions( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > parameters =
                new ArrayList< FieldDeclaration >();
        ArrayList< ExpressionDecl > expressionList = null;
        if ( entity != null ) {
            expressionList =
                    new ArrayList< ExpressionDecl >( JavaConversions.asJavaCollection( entity.getExpressionDecls() ) );

        } else {
            expressionList = new ArrayList<ExpressionDecl>( JavaConversions.asJavaCollection(
                    Frontend.getTopLevelExpressions( this.model() ) ) );
        }
        FieldDeclaration f;
        for ( ExpressionDecl expressionDecl : expressionList ) {
            Exp exp = expressionDecl.exp();

            // we don't want elaborations firing on their own.
            if ( hasElaboration(exp) ) continue;

            // we don't want effects firing on their own.
            if ( hasEffect(exp) ) continue;

            String name = new String( "expression" + expressionCounter++ );
            // String type = JavaToConstraintExpression.typeToClass( TypeChecker.exp2Type().get( exp ).toString() );
            String type = "Object";
            String expression = exp == null ? null : makeExpressionString(exp);

            ClassData.Param p =
                    new ClassData.Param( name, type, expression, null );
            f = createParameterField( p, initMembers );
            if ( f != null ) {
                parameters.add( f );
            }

        }

        return parameters;
    }

    public Collection< FieldDeclaration >
           getConstraints( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > constraints =
                new ArrayList< FieldDeclaration >();
        FieldDeclaration f;
        String expression;
        ArrayList< ConstraintDecl > constraintList;
        ArrayList< PropertyDecl > propertyList;
        //ArrayList< ExpressionDecl > exprList;
        if ( entity == null ) {
            constraintList =
                    new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelConstraints( this.model() ) ) );
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
//            exprList =
//                    new ArrayList< ExpressionDecl>( JavaConversions.asJavaCollection( Frontend.getTopLevelExpressions( this.model() ) ) );
        } else {
            constraintList =
                    new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( entity.getConstraintDecls() ) );
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDeclsNoIgnore() ) );
//            exprList =
//                    new ArrayList< ExpressionDecl >( JavaConversions.asJavaCollection( entity.getExpressionDecls() ) );
        }
        for ( ConstraintDecl constraint : constraintList ) {

            String name = get(constraint.name());
            expression = makeExpressionString(constraint.exp());

            f = createConstraintField( name, expression, initMembers );
            if ( f != null ) {
                constraints.add( f );
            }

        }

        for ( PropertyDecl property : propertyList ) {
            if ( !property.expr().isEmpty() &&
                 (allInitsAreConstraints || isPrimitive(property.ty().toJavaString()) )) {
                    /*
            if (allInitsAreConstraints || (isPrimitive(property.ty().toJavaString()) && property.expr().isEmpty())) {
                if ( property.expr().isEmpty() ) {
                    ClassData.Param p = makeParam( property, entity );
                    if (p.scope == null && entity != null ) p.scope = getClassName(entity);
                    String args[] =
                            expressionTranslator().convertToEventParameterTypeAndConstructorArgs( p, null );
                    if ( args != null && args.length > 3 ) {
                        expression = args[ 3 ];
                        //                    Statement s = createAssignmentOfGenericType( p.name, args[ 0 ],
                        //                                                                 args[ 1 ], args[ 2 ] );
                        //                    expression = s.toString().replaceFirst( "if [(][^)]*[)][^=]*[=]", "" ).replaceFirst( ";$","" );
                    } else {
                        expression = null;
                    }
                } else {
                    Exp pe = get(property.expr());
                    expression = makeExpressionString( pe );
                }
                    */
                Exp pe = get(property.expr());
                expression = makeExpressionString( pe );
                f = createConstraintField( null,
                                           property.name() + " == (" + expression + ")",
                                           initMembers );
                if ( f != null ) {
                    constraints.add( f );
                }
            }
        }

//        for ( ExpressionDecl property : exprList ) {
//
//            if ( !property.exp().isEmpty()
//                 && (allInitsAreConstraints || isPrimitive( property.ty().toJavaString() )) ) {
//                Exp pe = property.exp();
//                expression = makeExpressionString(pe);
//                f = createConstraintField( null,
//                                           property.name() + " == (" + expression + ")",
//                                           initMembers );
//                if ( f != null ) {
//                    constraints.add( f );
//                }
//            }
//        }

        return constraints;

    }

    public static Exp getScopeExp(Exp exp) {
        if ( exp instanceof FunApplExp ) {
            return getScopeExp( ((FunApplExp)exp).exp() );
        } else if ( exp instanceof DotExp ) {
            return ((DotExp)exp).exp();
        }
        return null;
    }

    public boolean hasEffect(Exp exp) {
        return getEffect(exp) != null;
    }
    public boolean isEffect(Exp exp) {
        return hasEffect(exp);
    }
    public FunApplExp getEffect(HasChildren exp) {
        if ( exp == null ) return null;
//        if ( exp instanceof BinExp ) {
//            BinExp fae = (BinExp)exp;
//            FunApplExp e = getEffect( fae.exp1() );
//            if ( e != null ) return e;
//            e = getEffect( fae.exp2() );
//            if ( e != null ) return e;
//            String callNoArgs = "" + fae.exp();
//            if (isEffectMethodName(callNoArgs)) {
//                return fae;
//            }
//            List<Argument> args = new ArrayList(JavaConversions.asJavaCollection(fae.args()));
//            if (callNoArgs.toLowerCase().startsWith("eq") && args.size() == 2 && args.get(1) instanceof FunApplExp) {
//                return getEffect((FunApplExp) args.get(1));
//            }
//        } else
        if ( exp instanceof FunApplExp ) {
            FunApplExp fae = (FunApplExp)exp;
            String callNoArgs = "" + fae.exp();
            if (isEffectMethodName(callNoArgs)) {
                return fae;
            }
            List<Argument> args = new ArrayList(JavaConversions.asJavaCollection(fae.args()));
            if (callNoArgs.toLowerCase().startsWith("eq") && args.size() == 2 && args.get(1) instanceof FunApplExp) {
                return getEffect((FunApplExp) args.get(1));
            }
//        } else if ( exp instanceof ParenExp ) {
//            return getEffect( ((ParenExp) exp).exp() );
        } else {
            Collection<Object> children = JavaConversions.asJavaCollection(exp.children());
            for ( Object c : children ) {
                if ( c instanceof HasChildren ) {
                    FunApplExp e = getEffect((HasChildren)c);
                    if ( e != null ) return e;
                }
            }
            // TODO???
        }
        return null;
    }
    public Pair<List<CallApplExp>, List<FunApplExp>> getElaborationExpressions(HasChildren exp) {
        if ( exp == null ) return null;
        ArrayList<CallApplExp> kConstructorCalls = new ArrayList<CallApplExp>();
        findKConstructorCalls( exp, kConstructorCalls, getClassData(), null );
        // Create constructors from calls to elaborate().
        ArrayList<FunApplExp> elaborationCalls = new ArrayList<FunApplExp>();
        findElaborationExpressions( exp, elaborationCalls, null );
        //elaborationCalls.addAll(kConstructorCalls, elaborationCalls);
        return new Pair(kConstructorCalls, elaborationCalls);
    }


    public boolean isEffectMethodName(String methodName) {
        if ( Utils.isNullOrEmpty(methodName) ) return false;
        int pos = methodName.lastIndexOf('.');
        if ( pos >= 0 && pos <  methodName.length() - 1 ) {
            methodName = methodName.substring(pos+1);
        }
        return TimeVaryingMap.effectMethodNames().contains(methodName);
    }

    public static boolean isFromBeginToEnd( HasChildren exp ) {
        if ( !( exp instanceof BinExp ) ) return false;
        BinExp d = (BinExp)exp;
        if (d.op() instanceof IMPL$ && d.exp1() instanceof BinExp) {
            BinExp firstArg = (BinExp) d.exp1();
            if (firstArg.op() instanceof AND$ && firstArg.exp1() instanceof BinExp) {
                BinExp firstFirstArg = (BinExp) firstArg.exp1();
                if ("time".equals(firstFirstArg.exp1().toString())) {
                    return true;
                }
            }
        }
        return false;
    }


    public ClassData.Param getMember( Exp e, String classScope ) {
        if (e instanceof DotExp) {
            return getMember((DotExp) e, classScope);
        } else if (e instanceof IdentExp) {
            return getMember((IdentExp) e, classScope);
        } // REVIEW -- TODO -- other cases?
        return null;
    }

    public ClassData.Param getMember( IdentExp e, String classScope ) {
        String oldCurrentClass = getClassData().getCurrentClass();
        getClassData().setCurrentClass( classScope );
        ClassData.Param p = null;
        try {  // This try/catch/finally is probably not necessary.
            p = getClassData().getParam(null, e.ident(), true, true,
                    false, false);
        } catch (Throwable t) {
            // ignore
        } finally {
            getClassData().setCurrentClass( oldCurrentClass );
        }
        return p;
    }

    public ClassData.Param getMember( DotExp de, String classScope ) {
        String type = globalName;
        String name = null;
        japa.parser.ast.expr.Expression javaExp =
                JavaToConstraintExpression.parseExpression(de.exp().toJavaString());
        name = de.ident();
        String oldCurrentClass = getClassData().getCurrentClass();
        getClassData().setCurrentClass( classScope );
        ClassData.Param p = null;
        try {  // This try/catch/finally is probably not necessary.
            type = expressionTranslator().astToAeExprType(javaExp, name, true, false);
            if ( name != null ) {
                p = getClassData().lookupMemberByName(type, name, true, false);
            }
        } catch (Throwable t) {
            // ignore
        } finally {
            getClassData().setCurrentClass( oldCurrentClass );
        }
        return p;
    }

    /**
     * The Java type of the K expression.  This is not complete for all expression types.
     * @param exp an AST element of parsed K; the classes of these elements are found in {@link k.frontend}.AbstractSyntax.scala
     * @param parent the parent scope, i.e. the name of the class immediately surrounding the expression
     * @return name of the Java type/class
     */
    public String getType(Object exp, String parent) {
        if ( exp == null ) return null;
        if ( exp instanceof HasChildren ) {
            return getType((HasChildren)exp, parent);
        }
        // These don't inherit from HasChildren
        if ( exp instanceof ThisLiteral ) {
            return parent;
        }
        if ( exp instanceof NullLiteral ) {
            return "Object";
        }
        String javaString = null;
        if ( exp instanceof Exp ) {
            javaString = ((Exp) exp).toJavaString();
        } else {
            javaString = "" + exp;
        }
        japa.parser.ast.expr.Expression javaExp =
                JavaToConstraintExpression.parseExpression(javaString);
        String type = expressionTranslator().astToAeExprType(javaExp, null, true, false);

        return type;
    }

    /**
     * The Java type of the K expression.  This is not complete for all expression types.
     * @param exp an AST element of parsed K; the classes of these elements are found in {@link k.frontend}.AbstractSyntax.scala
     * @param parent the parent scope, i.e. the name of the class immediately surrounding the expression
     * @return name of the Java type/class
     */
    public String getType(HasChildren exp, String parent) {
        String type = globalName;
        String name = null;
        if ( exp instanceof DotExp ) {
            DotExp de = (DotExp)exp;
            japa.parser.ast.expr.Expression javaExp =
                    JavaToConstraintExpression.parseExpression(de.exp().toJavaString());
            name = de.ident();
            type = expressionTranslator().astToAeExprType(javaExp, name, true, false);
        } else
        if ( exp instanceof IdentExp ) {
            //String type = ktoJava.globalName;
            type = getClassData().getClassNameWithScope( ((IdentExp)exp).toJavaString());
            if ( type == null ) {
                type = getClassData().getClassNameWithScope(parent);
                name = ((IdentExp)exp).toJavaString();
            }
        } else
        if ( exp instanceof StringLiteral ) {
            type = "String";
        } else
        if ( exp instanceof RealLiteral ) {
            type = "Double";
        } else
        if ( exp instanceof IntegerLiteral ) {
            type = "Integer";
        } else
        if ( exp instanceof BooleanLiteral ) {
            type = "Boolean";
        } else
        if ( exp instanceof DateLiteral ) {
            type = "Date";
        } else
        if ( exp instanceof DurationLiteral ) {
            type = "Duration";
        } else
        if ( exp instanceof CharacterLiteral ) {
            type = "Character";
        } else {
            String javaString = null;
            if ( exp instanceof Exp ) {
                javaString = ((Exp) exp).toJavaString();
            } else {
                javaString = "" + exp;
            }
            japa.parser.ast.expr.Expression javaExp =
                    JavaToConstraintExpression.parseExpression(javaString);
            type = expressionTranslator().astToAeExprType(javaExp, null, true, false);
        }

        if ( name != null ) {
            ClassData.Param p = getClassData().lookupMemberByName(type, name, true, false);
            if (p != null && p.type != null) {
                type = p.type;
            }
        }

        return type;
    }

    public boolean hasNonResourceVariable(ConstraintDecl constraintDecl, String parent ) {
        return hasNonResourceVariable( constraintDecl.exp(), parent );
    }

    public boolean hasNonResourceVariable( HasChildren exp, String parent ) {
        String type = globalName;
        String name = null;
        if ( exp instanceof DotExp ) {
            DotExp de = (DotExp)exp;
            japa.parser.ast.expr.Expression javaExp =
                    JavaToConstraintExpression.parseExpression(de.exp().toJavaString());
            name = de.ident();
            type = expressionTranslator().astToAeExprType(javaExp, name, true, false);
        } else if ( exp instanceof IdentExp ) {
            //String type = ktoJava.globalName;
            type = getClassData().getClassNameWithScope( parent );
            name = ((IdentExp)exp).toJavaString();
        }
        if ( name != null ) {
            ClassData.Param p = getClassData().lookupMemberByName(type, name, true, false);
            if (p != null) {
                if (!isStateVariableType(p.type)) {
                    return true;
                }
            }
        }
        Collection<Object> children = JavaConversions.asJavaCollection(exp.children());
        for ( Object c : children ) {
            if ( c instanceof HasChildren ) {
                if ( !isFromBeginToEnd( (HasChildren)c ) &&
                     hasNonResourceVariable((HasChildren)c, parent) ) {
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * Gather the effects of this entity but not in nested EntityDecls.
     * @param entity
     * @param initMembers
     * @return
     */
    public ArrayList<Pair<String, FieldDeclaration>>
    getEffects(MemberDecl entity, MethodDeclaration initMembers, boolean deep) {
        ArrayList<Pair<String, FieldDeclaration>> effects = new ArrayList<Pair<String, FieldDeclaration>>();
        Collection<Object> children = null;
        if ( entity == null ) {
            children = JavaConversions.asJavaCollection(this.model().children());
        } else {
            children = JavaConversions.asJavaCollection(entity.children());
        }
        if ( children == null ) return effects;
        for ( Object c : children ) {
            Exp exp = null;
            if ( c instanceof PropertyDecl ) {
                exp = get(((PropertyDecl) c).expr());
            } else if ( c instanceof ConstraintDecl ) {
                exp = ((ConstraintDecl) c).exp();
            } else if ( c instanceof ExpressionDecl ) {
                exp = ((ExpressionDecl) c).exp();
            } else if ( deep && c instanceof FunDecl ) {
                ArrayList<Pair<String, FieldDeclaration>> someEffects = getEffects((FunDecl)c, initMembers, deep);
                effects.addAll(someEffects);
            } else if ( deep && c instanceof EntityDecl ) {
                ArrayList<Pair<String, FieldDeclaration>> someEffects = getEffects((EntityDecl)c, initMembers, deep);
                effects.addAll(someEffects);
            }
            if ( exp != null ) {
                ArrayList<Pair<String, FieldDeclaration>> someEffects = getEffects(exp, initMembers);
                effects.addAll(someEffects);
            }
        }
        return effects;
    }

    public ArrayList<Pair<String, FieldDeclaration>>
    getEffects(Exp exp, MethodDeclaration initMembers) {
        ArrayList<Pair<String, FieldDeclaration>> effects = new ArrayList<Pair<String, FieldDeclaration>>();
        if ( isEffect(exp) ) {
            Expression expr = expressionTranslator().parseExpression( exp.toJavaString() );
            List<Pair<String, FieldDeclaration>> fields =
                    EventXmlToJava.createEffectField(expr, initMembers, getExpressionTranslator());
            effects.addAll(fields);
        }
        if ( exp == null || exp.children() == null ) return effects;
        Collection<Object> children = JavaConversions.asJavaCollection(exp.children());
        for ( Object c : children ) {
            if (c instanceof HasChildren) {
                if (c instanceof Exp ) {
                    ArrayList<Pair<String, FieldDeclaration>> someEffects = getEffects((Exp)c, initMembers);
                    effects.addAll(someEffects);
                }
            }
        }
        return effects;
    }


    public boolean isEffect(HasChildren exp) {
        if ( exp instanceof FunApplExp ) {
            FunApplExp f = (FunApplExp)exp;
            if ( f.name() != null && TimeVaryingMap.effectMethodNames().contains(f.name())) {
                return true;
            }
        }
        return false;
    }

    public boolean isEvent( String className ) {
        boolean isEvent = EventXmlToJava.isEvent(className, getClassData() );
        return isEvent;
    }


    public boolean hasElaboration( Exp exp ) {
        ArrayList<FieldDeclaration> elabs = getElaborations( exp, null );
        if ( !Utils.isNullOrEmpty( elabs ) ) return true;
        if ( exp instanceof FunApplExp && "elaborates".equals( ((FunApplExp)exp).name() ) ) {
            return true;
        }
        return false;
    }


    /**
     * Get the field declarations for adding elaborations to the event.
     * Elaborations can show up as constructor calls or elaborate() calls.
     * A constructor call may be constrained to equal a Parameter, or
     * it may be part of a larger expression in a constraint.  In the case that
     * the elaboration is re-instantiated (maybe due to a change in arguments),
     * the old elaboration needs to be deconstructed.
     * <p>
     * Consider an example:<br>
     * <code>var x = if b then dog.jump(startTime) else dog.sit(startTime)</code>
     * <p>
     * We need an ElaborationRule with <code>b</code> as the condition for
     * <code>dog.jump()</code> and <code>not(b)</code> as the condition for <code>dog.sit()</code>.
     * <p>
     * Consider another example:<br>
     * <code>req (b && x = dog.jump()) || x = dog.sit()</code>
     * <p>
     * We need an ElaborationRule with <code>b</code> as the condition for
     * <code>dog.jump()</code> and <code>not(b && x = dog.jump())</code> as the condition for <code>dog.sit()</code>.
     * <p>
     * Consider another example:<br>
     * <code>req (x.startTime > foo && x = dog.jump()) || (b && x = dog.sit())</code>
     * <p>
     * This is tricky.  The right thing to do is elaborate <code>dog.jump()</code>
     * and try to satisfy <code>x.startTime > foo</code>, but initially x will be null,
     * failing <code>x.startTime > foo</code> and blocking the construction of <code>dog.jump()</code>.
     * Do we try to recognize the dependency of <code>x.startTime > foo</code> on <code>x = dog.jump()</code>?
     *
     * @param entity
     * @param initMembers
     * @param deep
     * @return
     */
    public ArrayList< FieldDeclaration >
           getElaborations( EntityDecl entity, MethodDeclaration initMembers, boolean deep ) {
        ArrayList< FieldDeclaration > elaborations =
                new ArrayList< FieldDeclaration >();

        /* DurativeEvent.elaborates(..) works when elaborating from a
           TimeVaryingMap without special translation since it creates
           elaboration rules. So, code below should not be necessary.
           If not elaborating from TimeVarying, it's better to elaborate
           an event in the style of a constructor.

        // This gets elaborations specified with the elaborates() function.
        //Pair<List<FunApplExp>, List<FunApplExp>> p = getElaborationExpressions(entity);
        ArrayList<FunApplExp> elaboratesCalls = new ArrayList<FunApplExp>();
        findElaborationExpressions( entity, elaboratesCalls, null );
        for ( FunApplExp fae : elaboratesCalls ) {
            String name = null;
            Object enclosingInstance = null;
            String eventType = null;
            String eventName = null;
            List<ClassData.Param> arguments = new ArrayList<>();
            Collection<Argument> args = JavaConversions.asJavaCollection(fae.args());
            for (Argument a : args) {
                ClassData.Param p =
                        new ClassData.Param( null, null,
                                a.toJavaString(), null );
                arguments.add(p);
            }
            String fromTimeVarying = null;
            String conditionExpression = null;
            String applicableStartTime = null;
            String applicableEndTime = null;
            // TODO -- need something other than null args
            EventXmlToJava.createElaborationField(name, (String) enclosingInstance, eventType, eventName,
                    arguments, fromTimeVarying, conditionExpression, applicableStartTime,
                    applicableEndTime, initMembers,
                    getExpressionTranslator(), getClassData());
        }
        */
        Collection<Object> children = null;
        if ( entity == null ) {
            children = JavaConversions.asJavaCollection(this.model().children());
        } else {
            Collection<TopDecl> foo = JavaConversions.asJavaCollection(entity.children());
            children = new ArrayList<>();
            children.addAll(foo);
        }
        if ( children == null ) return elaborations;

        // Now get elaborations specified like function/constructor calls.
        //Collection<TopDecl> children = JavaConversions.asJavaCollection(entity.children());
        for ( Object c : children ) {
            if ( c instanceof TopDecl ) {
                ArrayList<FieldDeclaration> elabs = getElaborations((TopDecl) c, initMembers, deep);
                elaborations.addAll(elabs);
            }
        }

        return elaborations;
    }

    public ArrayList<FieldDeclaration> getElaborations( TopDecl decl,
                                                       MethodDeclaration initMembers,
                                                       boolean deep ) {
        ArrayList<FieldDeclaration> elaborations = new ArrayList<FieldDeclaration>();
        Exp exp = null;
        if ( decl instanceof PropertyDecl ) {
            exp = get(((PropertyDecl) decl).expr());
        } else if ( decl instanceof ConstraintDecl ) {
            exp = ((ConstraintDecl) decl).exp();
        } else if ( decl instanceof ExpressionDecl ) {
            exp = ((ExpressionDecl) decl).exp();
        } else if ( deep && decl instanceof FunDecl ) {
            ArrayList<FieldDeclaration> someElabs =
                    getElaborations((FunDecl)decl, initMembers, deep);
            elaborations.addAll(someElabs);
        } else if ( deep && decl instanceof EntityDecl ) {
            ArrayList<FieldDeclaration> someElabs =
                    getElaborations((EntityDecl)decl, initMembers, deep);
            elaborations.addAll(someElabs);
        }
        if ( exp != null ) {
            ArrayList<FieldDeclaration> someElabs =
                    getElaborations(exp, initMembers);
            elaborations.addAll(someElabs);
        }
        return elaborations;
    }

    public ArrayList<FieldDeclaration> getElaborations( Exp exp, MethodDeclaration initMembers ) {
        return getElaborations(exp, null, null, initMembers);
    }
    public ArrayList<FieldDeclaration> getElaborations( IfExp ifExp, Exp condition,
                                                       Exp enclosingInstance,
                                                       MethodDeclaration initMembers ) {
        ArrayList<FieldDeclaration> elaborations = new ArrayList<FieldDeclaration>();
        // true case
        Exp newCondition = condition == null
                ? ifExp.cond()
                : new BinExp(condition, AND$.MODULE$, ifExp.cond());
        ArrayList<FieldDeclaration> trueDecls =
                getElaborations(ifExp.trueBranch(), newCondition,
                                enclosingInstance, initMembers);
        if ( trueDecls != null ) elaborations.addAll(trueDecls);

        // false case
        newCondition = condition == null
                ? new UnaryExp(NEG$.MODULE$, ifExp.cond())
                : new BinExp(condition, AND$.MODULE$,
                new UnaryExp(NEG$.MODULE$, ifExp.cond()) );
        Exp falseBranch = get(ifExp.falseBranch());
        if ( falseBranch != null ) {
            ArrayList<FieldDeclaration> falseDecls =
                    getElaborations(falseBranch, newCondition,
                                   enclosingInstance, initMembers);
            if ( falseDecls != null ) elaborations.addAll(falseDecls);
        }
        return elaborations;
    }
    public ArrayList<FieldDeclaration> getElaborations( Exp exp, Exp condition,
                                                       Exp enclosingInstance,
                                                       MethodDeclaration initMembers ) {
        if ( exp instanceof IfExp ) {
            IfExp ifExp = (IfExp)exp;
            return getElaborations( ifExp, condition,
                                   enclosingInstance, initMembers );
        }
//        if ( exp instanceof DotExp ) {
//            return getElaborations( (DotExp)exp, condition,
//                                   enclosingInstance, initMembers );
//        }

        ArrayList< FieldDeclaration > elaborations = new ArrayList< FieldDeclaration >();
        if ( exp == null ) return elaborations;

        if ( exp instanceof CallApplExp && isConstructorCall( exp ) ) {
            CallApplExp cae = (CallApplExp)exp;
            if ( isEvent( cae.name() ) ) {
                if ( cae.exp1() instanceof DotExp ) {
                    enclosingInstance = ((DotExp) cae.exp1()).exp();
                }
                String name = null;
                String eventType = cae.name();
                String eventName = null;
                List<ClassData.Param> arguments = new ArrayList<>();
                Collection<Argument> args = JavaConversions.asJavaCollection(cae.args());
                for (Argument a : args) {
                    String pvalue = a.toJavaString();
                    String pname = null;
                    String ptype = null;
                    if ( a instanceof NamedArgument ) {
                        pname = ((NamedArgument)a).ident();
                    }
                    ClassData.Param p =
                            new ClassData.Param( pname, ptype, pvalue, null );
                    arguments.add(p);
                }
                String fromTimeVarying = null;
                String conditionExpression = condition == null ? null : condition.toJavaString();
                String applicableStartTime = null;
                String applicableEndTime = null;
                FieldDeclaration f =
                        EventXmlToJava.createElaborationField(
                                name,
                                enclosingInstance == null ? null : enclosingInstance.toJavaString(),
                                eventType, eventName, arguments,
                                fromTimeVarying, conditionExpression,
                                applicableStartTime, applicableEndTime,
                                initMembers, getExpressionTranslator(),
                                getClassData());
                elaborations.add(f);
            }
        }
        Collection<Object> children = JavaConversions.asJavaCollection(exp.children());
        for ( Object c : children ) {
            if ( c instanceof Exp ) {
                ArrayList<FieldDeclaration> elabs =
                        getElaborations( (Exp) c, condition, enclosingInstance,
                                        initMembers);
                if ( elabs != null ) {
                    elaborations.addAll( elabs );
                }
            }
        }
        return elaborations;
    }

    public ArrayList< FieldDeclaration > getElaborations( FunDecl fDecl,
                                                          MethodDeclaration initMembers,
                                                          boolean deep ) {
        // TODO
        ArrayList< FieldDeclaration > elaborations = new ArrayList< FieldDeclaration >();
        Collection<MemberDecl> members = JavaConversions.asJavaCollection(fDecl.body());
        for ( MemberDecl md : members ) {
            ArrayList<FieldDeclaration> elabs =
                    getElaborations(md, initMembers, deep);
            elaborations.addAll( elabs );
        }
        return elaborations;
    }


    // Add constructors for invocations.
    protected void addConstructors() {
      Collection< ConstructorDeclaration > constructors = getConstructorDeclarations(this.model());
      Collection<? extends ConstructorDeclaration> moreConstructors =
                createConstructors(this.model(), constructors);
      if ( moreConstructors != null ) {
          constructors.addAll(moreConstructors);
      }

      EventXmlToJava.addConstructors( constructors, getClassData() );
    }
    
    protected Collection< ? extends ConstructorDeclaration >
            createConstructors( Model model2,
                                Collection< ConstructorDeclaration > constructors ) {
        // TODO Auto-generated method stub
        return null;
    }


    public boolean isConstructorCall( HasChildren elem ) {
        return isConstructorCall( elem, getClassData() );
    }
    public static boolean isConstructorCall(HasChildren elem, ClassData classData) {
        if ( elem instanceof CtorApplExp )  {
            return true;
        }
        if ( elem instanceof FunApplExp )  {
            FunApplExp fae = (FunApplExp) elem;
            scala.collection.immutable.List<Argument> args = fae.arguments();
            scala.collection.Iterator iter = args.iterator();
            if ( iter.hasNext() ) {
                while( iter.hasNext() ) {
                    Object a = iter.next();
                    return ( a instanceof NamedArgument );
                }
            }
            String callName = fae.exp().toJavaString();
            if ( classData.isClassName(callName) ) {
                return true;
            }
            //TODO -- check for classes in Java/JVM?
        }
        return false;
    }

    protected static void findKConstructorCalls(HasChildren elem,
                                                ArrayList< CallApplExp > constructorCalls,
                                                ClassData classData,
                                                Seen<HasChildren> seen) {
        if ( elem == null ) return;
        Pair< Boolean, Seen<HasChildren>> p = Utils.seen(elem, true, seen );
        if ( p.first ) return;
        seen = p.second;
        if ( isConstructorCall( elem, classData ) ) {
            if ( elem instanceof CallApplExp ) {
                CallApplExp cae = (CallApplExp) elem;
                constructorCalls.add(cae);
            }
        }
        scala.collection.immutable.List<Object> children = elem.children();
        if (children == null) return;
        scala.collection.Iterator iter = children.iterator();
        while ( iter.hasNext() ) {
            Object o = iter.next();
            if ( o instanceof HasChildren ) {
                findKConstructorCalls( (HasChildren)o, constructorCalls, classData, seen);
            }
        }

    }
    protected static void findElaborationExpressions(HasChildren elem, ArrayList< FunApplExp > elaborations, Seen<HasChildren> seen) {
        if ( elem == null ) return;
        Pair< Boolean, Seen<HasChildren>> p = Utils.seen(elem, true, seen );
        if ( p.first ) return;
        seen = p.second;
        if ( elem instanceof FunApplExp )  {
            FunApplExp fae = (FunApplExp) elem;
            if ( fae.name().equals("elaborates") ) {
                if ( fae.args() != null && JavaConversions.asJavaCollection(fae.args()).size() >= 2 ) {
                    elaborations.add(fae);
                }
            }
        }
        scala.collection.immutable.List<Object> children = elem.children();
        if (children == null) return;
        scala.collection.Iterator iter = children.iterator();
        while ( iter.hasNext() ) {
            Object o = iter.next();
            if ( o instanceof HasChildren ) {
                findElaborationExpressions( (HasChildren)o, elaborations, seen);
            }
        }
    }

    protected ConstructorDeclaration getKConstructorDeclaration( CallApplExp fae ) {
        // get the class name
        String eventType = fae.name();//exp().toJavaString();
        // assume not elaborating from TimeVerying
        String fromTimeVarying = null;

        // get arguments
        List< ClassData.Param > arguments = new ArrayList<ClassData.Param>();
        scala.collection.Iterator iter = fae.args().iterator();
        while (iter.hasNext() ) {
            String paramName = null;
            Argument arg = (Argument)iter.next();
            Exp exp = null;
            if ( arg instanceof PositionalArgument) {
                PositionalArgument pa = (PositionalArgument)arg;
                exp = pa.exp();
            } else if  (arg instanceof NamedArgument ) {
                NamedArgument na = (NamedArgument)arg;
                exp = na.exp();
                paramName = na.ident();
            } else {
                Debug.error("Unrecognized argument: " + arg);
            }
            ClassData.Param param =
                    new ClassData.Param( paramName, (String)null,
                                         exp == null ? null : exp.toJavaString(), null );
            arguments.add(param);
        }

        ConstructorDeclaration ctor =
                EventXmlToJava.getConstructorDeclaration(eventType, fromTimeVarying,
                        arguments, expressionTranslator());
        return ctor;
    }

    protected ConstructorDeclaration getConstructorDeclaration( FunApplExp fae ) {
        String eventType = null;
        String fromTimeVarying = null;
        List< ClassData.Param > arguments = new ArrayList<ClassData.Param>();
        scala.collection.Iterator iter = fae.args().iterator();
        //for ( Argument arg : fae.args() ) {
        int ct = 0;
        while (iter.hasNext() ) {
            Argument arg = (Argument)iter.next();
            String name = null;
            Exp exp = null;
            String paramName = null;
            if ( arg instanceof PositionalArgument) {
                PositionalArgument pa = (PositionalArgument)arg;
                exp = pa.exp();
            } else if  (arg instanceof NamedArgument ) {
                NamedArgument na = (NamedArgument)arg;
                exp = na.exp();
                paramName = na.ident();
            } else {
                Debug.error("Unrecognized argument: " + arg);
            }
            if ( exp instanceof DotExp ) {
                DotExp de = (DotExp)exp;
                name = de.toString();
            } else
            if ( exp instanceof ClassExp ) {
                k.frontend.Type type = ((ClassExp)exp).ty();
                if ( type instanceof ClassType ) {
                    QualifiedName n = ((ClassType)type).ident();
                    name = n.toString();
                } else if ( type instanceof IdentType ) {
                    QualifiedName n = ((IdentType) type).ident();
                    name = n.toString();
                } else {
                    // shouldn't be possible
                }
            } else
            if ( exp instanceof IdentExp ) {
                name = ((IdentExp) exp).ident();
            } else if ( exp instanceof NullLiteral$ ){
                name = null;
                //Debug.error("Got NullLiteral: " + exp );
//                    if (!( exp instanceof NullLiteral )) {
//                        name = exp.toString();
//                    }
            } else {
                Debug.error("Unexpected k expression type: " + exp.getClass().getCanonicalName() );
            }
//                    } else if ( exp instanceof ) {
//                        makeParam()
//                    }
            if (eventType == null &&
                    (paramName == null || paramName.toLowerCase().contains("event"))) {
                eventType = name;
            } else if ( fromTimeVarying == null  &&
                    (paramName == null || paramName.toLowerCase().contains("timevarying"))) {
                fromTimeVarying = name;
            }

            // Handle arguments passed through to initialize the Event.
            if ( eventType != null && ( fromTimeVarying != null || ct > 2 ) ) {
                // Make sure that both the name of the Parameter and the Expression are together.
                if ( iter.hasNext() ) {
                    Argument arg2 = (Argument)iter.next();
                    ClassData.Param param = new ClassData.Param(("" + arg2).replaceAll("\"", ""), (String)null, arg.toJavaString(), null);
                    arguments.add(param);
                }
            } else if ( paramName != null ) {
                ClassData.Param param = new ClassData.Param(paramName, (String)null, arg.toJavaString(), null);
                arguments.add(param);
            }

            ++ct;
        }
        ConstructorDeclaration ctor =
                EventXmlToJava.getConstructorDeclaration(eventType, fromTimeVarying,
                        arguments, expressionTranslator());
        return ctor;
    }

    protected Collection< ConstructorDeclaration >
            getConstructorDeclarations( Model model ) {
        ArrayList<ConstructorDeclaration> ctors = new ArrayList<ConstructorDeclaration>();

        // Create constructors from constructor calls on k classes (which have named arguments).
        ArrayList<CallApplExp> kConstructorCalls = new ArrayList<>();
        findKConstructorCalls( model, kConstructorCalls, getClassData(), null );
        for ( CallApplExp fae : kConstructorCalls ) {
            ConstructorDeclaration ctor = getKConstructorDeclaration(fae);
            // TODO -- check if constructor is a duplicate of another, maybe just with the named arguments in a different order.
            ctors.add(ctor);
        }

        // Create constructors from calls to elaborate().
        ArrayList<FunApplExp> elaborationCalls = new ArrayList<FunApplExp>();
        findElaborationExpressions( model, elaborationCalls, null );
        for ( FunApplExp fae : elaborationCalls ) {
            ConstructorDeclaration ctor = getConstructorDeclaration(fae);
            // TODO -- don't add duplicates!
            ctors.add(ctor);
        }
        return ctors;
    }

//    protected ConstructorDeclaration getConstructorDeclaration(String eventType,
//                                                               String fromTimeVarying,
//                                                               List< ClassData.Param > arguments ) {
//        ConstructorDeclaration ctor =
//                new ConstructorDeclaration( ModifierSet.PUBLIC,
//                                            ClassUtils.simpleName(eventType) );
//        if ( Debug.isOn() ) Debug.outln("ctor ctord as " + ctor.getName() );
//        if ( !Utils.isNullOrEmpty( fromTimeVarying ) ) {
//            ClassData.Param p = new ClassData.Param("startTime", "Long", null);
//            arguments.add(p);
//            p = new ClassData.Param("duration", "Long", null);
//            arguments.add(p);
//        }
//        return ctor;
//    }

    public FieldDeclaration createConstraintField( String name,
                                                   String expression ) {

        if ( name == null ) {
            name = new String( "constraint" + constraintCounter++ );
        }

        String constructorArgs =
                expressionTranslator().javaToAeExpr( expression, "Boolean",
                                                   false );
        String constraintType = "ConstraintExpression";

        return createFieldOfGenericType( name, constraintType,
                                         constructorArgs );

    }

    // public String translateExpression(String expression) {
    //
    // }

    public FieldDeclaration
           createConstraintField( String name, String expression,
                                  MethodDeclaration initMembers ) {
        if ( initMembers == null ) {
            return createConstraintField( name, expression );
        }
        if ( name == null || name.trim().length() == 0 ) {
            name = new String( "constraint" + constraintCounter++ );
        }

        String constructorArgs =
                expressionTranslator().javaToAeExpr( expression, "Boolean",
                                                   true );
        // constructorArgs = "new Expression<Boolean>( \"" + expression +
        // "\", \"Java\" )";
        String constraintType = "ConstraintExpression";

        Statement s = createAssignmentOfGenericType( name, constraintType, null,
                                                     constructorArgs );
        ASTHelper.addStmt( initMembers.getBody(), s );

        FieldDeclaration f =  createFieldOfGenericType( name, constraintType, null, null );
        
        // deal with elaboration here?
        
        return f;
    }

    public FieldDeclaration createParameterField( ClassData.Param p ) {
        String args[] =
                expressionTranslator().convertToEventParameterTypeAndConstructorArgs( p, null );
        // return createFieldOfGenericType( p.name, type, p.type, args );
        return createFieldOfGenericType( p.name, args[ 0 ], null, // args[ 1 ],
                                         args[ 2 ] );
    }

    public FieldDeclaration
           createParameterField( ClassData.Param p,
                                 MethodDeclaration initMembers ) {
        if ( initMembers == null ) {
            return createParameterField( p );
        }
        String args[] =
                expressionTranslator().convertToEventParameterTypeAndConstructorArgs( p, null );
        Statement s = createAssignmentOfGenericType( p.name, args[ 0 ],
                                                     args[ 1 ], args[ 2 ] );
        ASTHelper.addStmt( initMembers.getBody(), s );
        FieldDeclaration f =
                createFieldOfGenericType( p.name, args[ 0 ], args[ 1 ], null );

        return f;
    }

    public void
           createEnclosingInstanceStatment( EntityDecl entity,
                                            MethodDeclaration initMembers ) {
        //String simpleName = null;
        String fqName = null;

        if (entity != null) {
            //simpleName = entity.ident();
            fqName = entity.fqName();
        }

        String enclosing = getClassData().getEnclosingClassName(fqName);
        if (enclosing != null) {
            String stmtString = "enclosingInstance = " + enclosing + ".this;";
            ASTParser parser = new ASTParser( new StringReader( stmtString ) );
            Statement stmt = null;
            try {
                stmt = parser.BlockStatement();
            } catch ( ParseException e ) {
                e.printStackTrace();
            }
            ASTHelper.addStmt( initMembers.getBody(), stmt );
        }
        

    }

    public static FieldDeclaration
           createFieldOfGenericType( String name, String typeName,
                                     String parameterTypeName,
                                     String constructorArgs ) {
        String fieldTypeName = typeName;
        if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
            fieldTypeName +=
                    "< " + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                             + " >";
        }
        ClassOrInterfaceType fieldType =
                new ClassOrInterfaceType( fieldTypeName );
        FieldDeclaration f = null;
        VariableDeclaratorId id = new VariableDeclaratorId( name );
        Expression init = null;
        String initValue = null;
        if ( constructorArgs == null ) {
            initValue = "null";
        } else {
            initValue = "new " + typeName;
            if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
                initValue +=
                        "< " + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                             + " >";
            }
            initValue += "( " + constructorArgs + " )";
        }
        init = new NameExpr( initValue );
        VariableDeclarator variable = new VariableDeclarator( id, init );
        f = ASTHelper.createFieldDeclaration( ModifierSet.PUBLIC, fieldType,
                                              variable );
        return f;
    }

    public static Statement
           createAssignmentOfGenericType( String name, String typeName,
                                          String parameterTypeName,
                                          String constructorArgs ) {
        StringBuffer stmtsString = new StringBuffer();
        stmtsString.append( "if ( " + name + " == null ) " );
        stmtsString.append( name + " = " );
        if ( constructorArgs == null ) {
            stmtsString.append( "null;" );
        } else {
            stmtsString.append( "new " + typeName );
            if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
                stmtsString.append( "< "
                                    + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                                    + " >" );
            }
            stmtsString.append( "( " + constructorArgs + " );" );
        }

        if ( Debug.isOn() ) Debug.outln( "Trying to parse assignment with ASTParser.BlockStatement(): \""
                                         + stmtsString.toString() + "\"" );
        ASTParser parser =
                new ASTParser( new StringReader( stmtsString.toString() ) );
        Statement stmt = null;
        try {
            stmt = parser.BlockStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
        }

        return stmt;
    }

    public static FieldDeclaration
           createFieldOfGenericType( String name, String typeName,
                                     String constructorArgs ) {
        return createFieldOfGenericType( name, typeName, null,
                                         constructorArgs );
    }

    protected MethodDeclaration createPublicVoidMethod( String methodName ) {
        MethodDeclaration initMembers =
                new MethodDeclaration( ModifierSet.PUBLIC, new VoidType(),
                                       methodName );
        initMembers.setBody( new BlockStmt() );
        return initMembers;
    }

    public static void addStatements( BlockStmt block, String stmts ) {
        addStatements( block, -1, stmts );
    }

    public static void addStatements( BlockStmt block, int pos, String stmts ) {
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );
        List< Statement > list = stringToStatementList( stmts );
        addStmts( block, pos, list );
    }

    private static void addStmts( BlockStmt block, List< Statement > list ) {
        addStmts( block, -1, list );
    }

    private static void addStmts( BlockStmt block, int pos,
                                  List< Statement > list ) {
        if ( list != null ) {
            if ( pos == -1 ) {
                if ( block == null
                     || Utils.isNullOrEmpty( block.getStmts() ) ) {
                    pos = 0;
                } else {
                    pos = block.getStmts().size();
                }
            }
            for ( Statement stmt : list ) {
                addStmt( block, pos++, stmt );
            }
        }
    }

    public static void addStmt( BlockStmt block, int pos, Statement stmt ) {
        List< Statement > stmts = block.getStmts();
        if ( stmts == null ) {
            stmts = new ArrayList< Statement >();
            block.setStmts( stmts );
        }
        if ( pos == -1 ) {
            stmts.add( stmt );
        } else {
            stmts.add( pos, stmt );
        }
    }

    public static List< Statement > stringToStatementList( String s ) {
        if ( Debug.isOn() ) Debug.outln( "trying to parse Java statements \""
                                         + s + "\"" );
        ASTParser parser = new ASTParser( new StringReader( s ) );
        List< Statement > stmtList = null;
        try {
            stmtList = parser.Statements();
        } catch ( Throwable e ) {
            System.err.println( "\nError parsing Java: \"" + s + "\"" );
            e.printStackTrace();
        }
        return stmtList;
    }

    protected void setPackage() {
        // set the package based on the xmlFileName
        // String packageName =
        // "generated."
        // + xmlFileName.substring( 0, xmlFileName.lastIndexOf( '.' ) )
        // .replaceAll( "[^A-Za-z0-9_]+", "_" );
        if ( Utils.isNullOrEmpty(packageName) ) return;
        if ( Debug.isOn() ) Debug.outln( "setting package for current compilation unit to "
                                         + packageName );
        getClassData().getCurrentCompilationUnit()
                      .setPackage( new PackageDeclaration( ASTHelper.createNameExpr( packageName ) ) );
    }

    private CompilationUnit initCompilationUnit( String name ) {
        getClassData().setCurrentCompilationUnit( new CompilationUnit() );
        getClassData().getClasses()
                      .put( ClassUtils.simpleName( name ),
                            getClassData().getCurrentCompilationUnit() );
        setPackage();
        return getClassData().getCurrentCompilationUnit();
    }

    private CompilationUnit initClassCompilationUnit( String name ) {
        getClassData().setCurrentCompilationUnit( initCompilationUnit( ClassUtils.simpleName( name ) ) );
        // REVIEW -- How can we access eclipse's ability to auto-remove unused
        // imports?
        // addImport( "gov.nasa.jpl.ae.event.*" );
        addImport( "gov.nasa.jpl.ae.event.Parameter" );
        addImport( "gov.nasa.jpl.ae.event.IntegerParameter" );
        addImport( "gov.nasa.jpl.ae.event.LongParameter" );
        addImport( "gov.nasa.jpl.ae.event.DoubleParameter" );
        addImport( "gov.nasa.jpl.ae.event.StringParameter" );
        addImport( "gov.nasa.jpl.ae.event.BooleanParameter" );
        addImport( "gov.nasa.jpl.ae.event.StateVariable" );
        addImport( "gov.nasa.jpl.ae.event.Timepoint" );
        addImport( "gov.nasa.jpl.ae.event.Expression" );
        addImport( "gov.nasa.jpl.ae.event.ConstraintExpression" );
        addImport( "gov.nasa.jpl.ae.event.Functions" );
        addImport( "gov.nasa.jpl.ae.event.FunctionCall" );
        addImport( "gov.nasa.jpl.ae.event.ConstructorCall" );
        addImport( "gov.nasa.jpl.ae.event.Call" );
        addImport( "gov.nasa.jpl.ae.event.Effect" );
        addImport( "gov.nasa.jpl.ae.event.EffectFunction" );
        addImport( "gov.nasa.jpl.ae.event.TimeDependentConstraintExpression" );
        addImport( "gov.nasa.jpl.ae.event.Dependency" );
        addImport( "gov.nasa.jpl.ae.event.ElaborationRule" );
        addImport( "gov.nasa.jpl.ae.event.EventInvocation" );
        addImport( "gov.nasa.jpl.ae.event.DurativeEvent" );
        addImport( "gov.nasa.jpl.ae.event.ParameterListenerImpl" );
        addImport( "gov.nasa.jpl.ae.event.TimeVaryingMap" );
        addImport( "gov.nasa.jpl.ae.event.Consumable" );
        addImport( "gov.nasa.jpl.ae.event.Timeline" );
        addImport( "gov.nasa.jpl.ae.event.TimeVaryingFunctionCall" );
        addImport( "gov.nasa.jpl.ae.event.Event" );
        addImport( "gov.nasa.jpl.ae.solver.ObjectDomain" );
        addImport( "gov.nasa.jpl.mbee.util.TimeUtils" );
        addImport( "gov.nasa.jpl.mbee.util.Utils" );
        addImport( "gov.nasa.jpl.mbee.util.Debug" );
        addImport( "gov.nasa.jpl.mbee.util.ClassUtils" );
        addImport( "java.util.Vector" );
        addImport( "java.util.Map" );
        addImport("java.util.ArrayList");
        addImport("java.util.Arrays");
        addImport( "java.util.TimeZone" );
        if ( Utils.getJavaVersion() >= 1.8 ) {
            addImport("java.time.Duration");
        }
        return getClassData().getCurrentCompilationUnit();
    }

    private void addImport( String impName ) {
        EventXmlToJava.addImport( impName, getClassData() );
    }

    private void addTryCatchToInitMembers( MethodDeclaration initMembers ) {
        TryStmt tryStmt = null;

        // Need to add a statement that will certainly need all of these
        // exceptions;
        // otherwise, we'll get a compile error for trying to catch something
        // that
        // can't be thrown. Test code commented out below.
        String pkg = packageName + ".";
        if ( pkg.length() == 1 ) {
            pkg = "";
        }

        String tryCatchString = "try{\n" + ";\n" + "} catch ( Exception e ) {\n"
                                + "  // TODO Auto-generated catch block\n"
                                + "  e.printStackTrace();\n" + "}\n";

        List< Statement > stmts = new ArrayList< Statement >();
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );

        ASTParser parser = new ASTParser( new StringReader( tryCatchString ) );
        try {
            tryStmt = parser.TryStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
            return;
        }
        tryStmt.setTryBlock( initMembers.getBody() );
        stmts.add( tryStmt );
        BlockStmt newBody = new BlockStmt( stmts );
        initMembers.setBody( newBody );
    }

    private MethodDeclaration
            createInitCollectionsMethod( String methodName,
                                         Collection< FieldDeclaration > parameters,

                                         Collection< FieldDeclaration > constraints,
                                         Collection<  Pair< String, FieldDeclaration > > effects ) {
        MethodDeclaration initCollections =
                new MethodDeclaration( ModifierSet.PROTECTED, new VoidType(),
                                       methodName );
        // TODO -- Add initCollections()'s body.
        BlockStmt block = new BlockStmt();
        List< Statement > stmtList = null;
        stmtList = createStmtsFromFieldCollection( "parameters.add( ",
                                                   parameters, " );\n" );
        addStmts( block, stmtList );
        stmtList =
                createStmtsFromFieldCollection( "constraintExpressions.add( ",
                                                constraints, " );\n" );
        addStmts( block, stmtList );

        if ( effects != null ) {
            stmtList = EventXmlToJava.createEffectStmtsFromFieldCollection(
                    "addEffects( (Parameter< ? >)",
                    effects,
                    " );\n",
                    getClassData() );
            addStmts( block, stmtList );
        }

        initCollections.setBody( block );
        return initCollections;
    }

    private List< Statement > createStmtsFromFieldCollection( String prefix,
                                                              Collection< FieldDeclaration > fieldCollection,
                                                              String suffix ) {
        if ( fieldCollection == null || fieldCollection.isEmpty() ) return null;
        // private Statement createInitCollectionStmt( String collectionName,
        // Collection< FieldDeclaration > fieldCollection ) {
        StringBuilder sb = new StringBuilder();
        for ( FieldDeclaration f : fieldCollection ) {
            // sb.append(" " + collectionName + ".add( " + f.getVariables().get(
            // 0
            // ) + " );\n" );
            sb.append( prefix + f.getVariables().get( 0 ).getId() + suffix );
        }
        return stringToStatementList( sb.toString() );
    }


    protected void processExecutionEvent() { 

        getClassData().setCurrentClass( "Main" );
        initClassCompilationUnit( getClassData().getCurrentClass() );

        ClassOrInterfaceDeclaration newClassDecl =
                new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                 getClassData().getCurrentClass() );
        ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                      newClassDecl );

        int mods = ModifierSet.PUBLIC | ModifierSet.STATIC;

        MethodDeclaration setupMethodDecl =
                new MethodDeclaration( mods, new VoidType(), "setup" );
        BlockStmt setupBody = new BlockStmt();
        setupMethodDecl.setBody( setupBody );

        MethodDeclaration initCustomMethodDecl =
                new MethodDeclaration( ModifierSet.PUBLIC, new VoidType(), "init" + globalName + "Custom" );
        BlockStmt initCustomBody = new BlockStmt();
        initCustomMethodDecl.setBody( initCustomBody );
        // TODO -- REVIEW -- Is the horizon timepoint protected from getting changed?  Consider changing it's construction in Timepoint to restrict its domain.
        addStatements(initCustomBody, "addDependency(startTime, new Expression<Long>(0L));\n" +
                                      "addDependency(duration, new Expression<Long>(Timepoint.getHorizonTimepoint()));");

        MethodDeclaration runMethodDecl =
                new MethodDeclaration( mods, new ClassOrInterfaceType("Main"), "run" );
        BlockStmt runBody = new BlockStmt();
        runMethodDecl.setBody( runBody );
        MethodDeclaration mainMethodDecl =
                new MethodDeclaration( mods, new VoidType(), "main" );
        BlockStmt mainBody = new BlockStmt();
        mainMethodDecl.setBody( mainBody );

        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt ctorBody = new BlockStmt();
        ctor.setBlock( ctorBody );

        Type type = ASTHelper.createReferenceType( "String", 1 );
        VariableDeclaratorId id = new VariableDeclaratorId( "args" );
        japa.parser.ast.body.Parameter parameter =
                new japa.parser.ast.body.Parameter( type, id );
        // Wire everything together.
        ASTHelper.addParameter( mainMethodDecl, parameter );
        ASTHelper.addParameter( runMethodDecl, parameter  );
        ASTHelper.addMember( newClassDecl, setupMethodDecl );
        ASTHelper.addMember( newClassDecl, runMethodDecl );
        ASTHelper.addMember( newClassDecl, mainMethodDecl );
        ASTHelper.addMember( newClassDecl, initCustomMethodDecl );

        // List< PropertyDecl > topLevelProperties =
        // new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection(
        // Frontend.getTopLevelProperties( this.model ) ) );
        // PropertyDecl toExecute = topLevelProperties.get( 0 );
        // String className = toExecute.ty().toJavaString();
        // String instanceName = toExecute.name();
        // if ( instanceName == null || instanceName.isEmpty() ) {
        // instanceName = className + ( counter++ );
        // }

        addExtends( newClassDecl, globalName );

        StringBuffer stmtsMain = new StringBuffer();

        // stmtsMain.append( "Main scenario = new Main();" );
        // stmtsMain.append( "scenario.amTopEventToSimulate = true;" );
        // stmtsMain.append( "System.out.println(\"===FULLOUTPUT===\" );" );
        // stmtsMain.append( "scenario.satisfy( true, null );" );
        // stmtsMain.append( "System.out.println(\"===RESULTS===\" );" );
        // stmtsMain.append( "System.out.println(scenario.kSolutionString());"
        // );
        String targetDirectory = getPackageSourcePath( null );
        String x = "Timepoint.setUnits(\"" + Timepoint.getUnits().toString() + "\");\n" +
                "Timepoint.setEpoch(\"" + TimeUtils.toAspenTimeString(Timepoint.getEpoch()) + "\");\n" +
                "Timepoint.setHorizonDuration(" + Timepoint.getHorizonDuration() + "L);\n";
        addStatements( setupBody, x );
        String y = "      JSONObject json = new JSONObject();\n";
        if ( !this.processStdoutAndStderr ) {
            y +=    "      setup();\n" +
                    "      Main s = new Main();\n" +
                    "      s.amTopEventToSimulate = true;\n" +
                    "      System.out.println(\"===FULLOUTPUT===\" );\n" +
                    "      s.executeAndSimulate();\n" +
                    "      System.out.println(\"===RESULTS===\" );\n" +
                    "      System.out.println(s.kSolutionString());\n" +
                    "\n";
            y +=    "      JSONObject solution = s.kSolutionJson();\n" +
                    "      json.put(\"result\", solution);\n" +
                    "\n" +
                    "      System.out.println(json.toString(4));";
            y +=    "      return s;\n";
        } else {
            y +=    "        CaptureStdoutStderr c = new CaptureStdoutStderr() {\n" +
                    "            @Override\n" +
                    "            public Object run() {\n" +
                    "                setup();\n" +
                    "                Main scenario = null;\n" +
                    "                try {\n" +
                    "                    scenario = new Main();\n" +
                    "                    scenario.amTopEventToSimulate = true;\n" +
                    (verbose ?
                            "                System.out.println(\"===FULLOUTPUT===\" );\n" : "") +
                    "                    scenario.executeAndSimulate();\n" +
                    "                } catch( Throwable t ) {\n" +
                    "                    t.printStackTrace();\n" +
                    "                }\n" +
                    "                return scenario;\n" +
                    "            }\n" +
                    "        };\n" +
                    "\n" +
                    "        Main s = (Main) c.result;\n" +
                    "\n" +
                    "        String out = c.baosOut.toString();\n" +
                    "        String path = \"" + targetDirectory + File.separator + "solverOutput.log\";\n" +
                    "        FileUtils.stringToFile(out, path);\n" +
                    "\n" +
                   // "        File f = new File(path);\n" +
                    //"        json.put(\"solverOutFile\",f.getAbsolutePath());\n" +
                    "\n" +
                    "        if ( c.baosErr.toString().length() > 3 ) {\n" +
                    "            JSONArray jarr = json.has(\"solverErrors\") ? json.getJSONArray(\"solverErrors\") : null;\n" +
                    "            if (jarr == null) jarr = new JSONArray();\n" +
                    "            jarr.put(c.baosErr);\n" +
                    "            json.put(\"Solver Errors\", jarr);\n" +
                    "        }\n" +
                    "\n" +
                    (verbose ?
                    "      System.out.println(\"===RESULTS===\" );\n" +
                    "      System.out.println(s.kSolutionString());\n" : "");
            y +=    "        CaptureStdoutStderr cj = new CaptureStdoutStderr() {\n" +
                    "            @Override\n" +
                    "            public Object run() {\n" +
                    "                JSONObject jo = null;\n" +
                    "                try {\n" +
                    "                    jo = s.kSolutionJson();\n" +
                    "                } catch( Throwable t ) {\n" +
                    "                }\n" +
                    "                return jo;\n" +
                    "            }\n" +
                    "        };\n";
            y +=    "      JSONObject solution = (JSONObject)cj.result;\n" +
                    "      json.put(\"result\", solution);\n" +
                    "\n" +
                    "      System.out.println(json.toString(4));";
            y +=    "      return s;\n";
        }
        stmtsMain.append(y);


        List< Expression > args = new ArrayList< Expression >();

        ASTHelper.addStmt( ctorBody,
                           new ExplicitConstructorInvocationStmt( false, null,
                                                                  args ) );

        addImport( "gov.nasa.jpl.ae.event.Expression" );
        addImport( "gov.nasa.jpl.ae.util.CaptureStdoutStderr" );
        addImport( "gov.nasa.jpl.mbee.util.FileUtils" );
        addImport( "java.io.File" );
        addImport( "org.json.JSONArray" );
        addImport( "org.json.JSONObject" );

        addStatements( runBody, stmtsMain.toString() );
        addStatements(mainBody, "run(args);\n");
    }

    protected static void addExtends( ClassOrInterfaceDeclaration newClassDecl,
                                      String superClass ) {
        if ( newClassDecl.getExtends() == null ) {
            newClassDecl.setExtends( new ArrayList< ClassOrInterfaceType >() );
        }
        newClassDecl.getExtends().add( new ClassOrInterfaceType( superClass ) );
    }

    public EntityDecl getEntity(String name) {
        if ( Utils.isNullOrEmpty(name) ) return null;
        String nameNoTypeArgs = ClassUtils.noParameterName(name);
        if ( Utils.isNullOrEmpty(nameNoTypeArgs) ) return null;
        for ( EntityDecl e : getAllClasses() ) {
            if ( e == null ) continue;
            String scopedName = getClassData().getClassNameWithScope( e.ident() );
            if ( Utils.isNullOrEmpty(scopedName) ) scopedName = e.ident();
            if ( !Utils.isNullOrEmpty(scopedName) && scopedName.endsWith( nameNoTypeArgs ) ) {
                int posBefore = scopedName.length() - nameNoTypeArgs.length() - 1;
                if ( posBefore < 0 || scopedName.charAt( posBefore ) == '.' ) {
                    // TODO -- There could be multiple matches!
                    return e;
                }
            }
        }
        return null;
    }

    public boolean isStateVariable(PropertyDecl propertyDecl) {
        String typeName = propertyDecl.ty().toString().replaceAll("\\[.*\\]", "");
        String typeNameJava = propertyDecl.ty().toJavaString().replaceAll("<.*>", "");;
        if ( !typeName.equals(typeNameJava) ) {
            if ( someStateVariableClassNames.contains(typeNameJava) ) {
                return true;
            }
        }
        return isStateVariableType(typeName);
    }
    public boolean isStateVariableType(EntityDecl e) {
        if ( e == null ) return false;
        List<k.frontend.Type> supers = getSuperClasses(e);
        for ( k.frontend.Type t : supers ) {
            if ( isStateVariableType( t ) ) {
                return true;
            }
        }
        return false;
    }

    public boolean isStateVariableType(k.frontend.Type type) {
        return isStateVariableType( type.toString() );
    }
    public boolean isStateVariableType(ClassOrInterfaceType type) {
        return isStateVariableType( type.toString() );
    }

    protected static Set<String> someStateVariableClassNames =
            new LinkedHashSet<String>(Utils.arrayAsList(new String[]{
                    "TimeVaryingMap", "TimeVarying", "PlottableTimeVaryingMap", "Consumable", "ObjectFlow", "TimeVaryingList"
            }));

    public boolean isStateVariableType(String typeName) {
        if ( typeName == null ) return false;
        if ( someStateVariableClassNames.contains(typeName) ) return true;

        EntityDecl e = getEntity(typeName);
        if ( e != null ) {
            return isStateVariableType( e );
        }
        List<Class<?>> classes = ClassUtils.getClassesForName(typeName, true);
        if ( !Utils.isNullOrEmpty(classes) ) {
            boolean someNotTimeVarying = false;
            boolean someTimeVarying = false;
            for ( Class<?> cls : classes ) {
                if ( isStateVariableType( cls ) ) {
                    someTimeVarying = true;
                } else {
                    someNotTimeVarying = true;
                }
            }
            if ( !someNotTimeVarying && !someTimeVarying ) {
                Debug.error(true, false,
                        "WARNING! Multiple possible recognized classes found for " +
                                typeName + ".  Not sure if it is a state variable (TimeVarying)." );
            }
            return someTimeVarying;
        }
        return false;
    }

    public boolean isStateVariableType(Class<?> cls) {
        if ( TimeVarying.class.isAssignableFrom( cls ) ) {
            return true;
        }
        // Don't need to check superclasses.
        return false;
    }

    public List<Object> getSuperClasses(Object typeO) {
        if ( typeO == null )
        if ( typeO instanceof k.frontend.Type ) {
            return getSuperClasses((Type)typeO);
        }
        if ( typeO instanceof Class ) {
            List<Class<?>> supers = getSuperClasses((Class<?>) typeO);
            return Utils.asList(supers, Object.class);
        }
        return getSuperClasses("" + typeO );
    }
    public List<Class<?>> getSuperClasses(Class<?> cls) {
        List<Class<?>> supers = new ArrayList<>();
        Class<?> superCls = cls.getSuperclass();
        supers.add( superCls );
        Class<?>[] interfaces = cls.getInterfaces();
        supers.addAll(Utils.arrayAsList(interfaces));
        return supers;
    }
    public List<k.frontend.Type> getSuperClasses(EntityDecl e) {
        List< k.frontend.Type > types =
                new ArrayList< k.frontend.Type >( JavaConversions.asJavaCollection( e.extending() ) );
        return types;
    }
    public List<Object> getSuperClasses(String typeName) {
        if ( typeName == null ) return null;
        EntityDecl e = getEntity(typeName);
        if ( e != null ) {
            List<k.frontend.Type> supers = getSuperClasses(e);
            return Utils.asList(supers, Object.class);
        }
        List<Class<?>> classes = ClassUtils.getClassesForName(typeName, true);
        if ( !Utils.isNullOrEmpty(classes) ) {
            if ( classes.size() > 1 ) {
                Debug.error(true, false,
                        "WARNING! Multiple possible recognized classes found for " +
                                typeName + ": " + classes + "; choosing first.");
            }
            Class<?> cls = classes.get(0);
            List<Class<?>> supers = getSuperClasses(cls);
            return Utils.asList(supers, Object.class);
        }
        return null;
    }
    public List<Object> getSuperClasses(k.frontend.Type type) {
        String typeName = type.toString();
        List<Object> supers = getSuperClasses( typeName );
        if ( !Utils.isNullOrEmpty(supers) ) {
            return supers;
        }
        String javaTypeName = type.toJavaString();
        if ( !typeName.equals(javaTypeName) ) {
            supers = getSuperClasses(javaTypeName);
        }
        return supers;
    }


    public String getPackageSourcePath( String projectPath ) {
        if ( projectPath == null ) {
            projectPath = "";
        } else {
            projectPath += File.separator;
        }
        String packagePath =
                getPackageName().replace( '.', File.separatorChar );
        String srcPath = projectPath + EventXmlToJava.generatedCodeLocation + File.separator + packagePath;
        return srcPath;
    }

    public String getPackageName() {
        return this.packageName;
    }

    public void writeFiles( String directory ) {
        javaFiles = writeFiles(this, directory, packageName );
    }

    public static ArrayList<String> writeFiles( KtoJava translator, String directory, String packageName ) {
        ArrayList<String> javaFiles = new ArrayList<String>();
        if ( translator == null ) return javaFiles;
        if ( translator.expressionTranslators == null ) return javaFiles;
        String originalPackageName = translator.packageName;
        for ( Map.Entry<String, JavaToConstraintExpression> e :
              translator.expressionTranslators.entrySet() ) {
            String pName = e.getKey();
            JavaToConstraintExpression xlator = e.getValue();
            ClassData classData = xlator.getClassData();
            Model m = translator.model(pName);
            if ( m == null ) continue;
            translator.packageName = pName;
            ArrayList<String> someJavaFiles =
                    EventXmlToJava.writeFiles(classData, directory, pName );
            if ( someJavaFiles != null ) {
                javaFiles.addAll( someJavaFiles );
            }
        }
        translator.packageName = originalPackageName;
        return javaFiles;
        /*
        if ( translator == null ) {
            return;
        }
        // Figure out where to write the files
        String targetDirectory = translator.getPackageSourcePath( null );
        if ( targetDirectory == null ) {
            if ( directory == null ) {
                targetDirectory = translator.packageName;
            } else {
                targetDirectory = directory + File.separator + translator.packageName;
            }
        }

        // Create the directory for the package where the files will be
        // written
        // and see if the directory exists.
        File targetDirectoryFile = new File( targetDirectory );
        if ( !targetDirectoryFile.exists() ) {
            if ( !targetDirectoryFile.mkdirs() ) {
                System.err.println( "Error! Unable to make package directory: "
                                    + targetDirectoryFile.getAbsolutePath() );
            }
        } else {
            assert targetDirectoryFile.isDirectory();
        }

        // Delete old Java and class files.
        File[] files =
                EventXmlToJava.getJavaFileList( targetDirectoryFile );
        Debug.outln( "Deleting old .java files in "
                     + targetDirectoryFile.getAbsolutePath() + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );
        files = translator.getJavaFiles( targetDirectory, false, false );
        Debug.outln( "Deleting old .class files in "
                     + targetDirectoryFile.getAbsolutePath() + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );
        String binDir = targetDirectoryFile.getAbsolutePath()
                                           .replaceFirst( "([^a-zA-Z])src([^a-zA-Z])",
                                                          "$1bin$2" );
        files = translator.getJavaFiles( binDir, false, false );
        Debug.outln( "Deleting old .class files in " + binDir + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );

        // Now write the files.
        try {
            translator.writeJavaFiles( targetDirectory );
        } catch ( IOException e ) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
     */
    }

    public void writeJavaFiles( String javaPath ) throws IOException {
        EventXmlToJava.writeJavaFiles( javaPath, getClassData() );
    }

    public static File[] getJavaFileList( File path ) {
        File[] fileArr = null;
        assert path.exists();
        fileArr = path.listFiles();
        return fileArr;
    }

    public static File[] getJavaFileList( String javaPath ) {
        File[] fileArr = null;
        File path = new File( javaPath );
        return getJavaFileList( path );
    }

    public File[] getJavaFiles( String javaPath, boolean sourceOrClass,
                                boolean justCurrentClasses ) {
        File[] fileArr = null;
        File path = new File( javaPath );
        if ( javaPath == null ) {
            javaPath = ( sourceOrClass ? "src" : "bin" ) + File.separator
                       + this.packageName;
            File path2 = new File( javaPath );
            if ( !path2.exists() && !sourceOrClass ) {
                javaPath = "src" + File.separator + this.packageName;
                path2 = new File( javaPath );
            }
            if ( !path2.exists() && sourceOrClass) {
                javaPath = EventXmlToJava.generatedCodeLocation + File.separator
                        + this.packageName;
                path2 = new File( javaPath );
            }
            if ( path2.exists() ) {
                path = path2;
            }
        }
        assert path.exists();
        if ( !justCurrentClasses ) {
            fileArr = getJavaFileList( path );
            if ( fileArr != null ) {
                List< File > files = new ArrayList< File >();
                for ( File f : fileArr ) {
                    if ( f.getName()
                          .endsWith( sourceOrClass ? ".java" : ".class" ) ) {
                        files.add( f );
                    }
                }
                fileArr = new File[ files.size() ];
                int ctr = 0;
                for ( File f : files ) {
                    fileArr[ ctr++ ] = f;
                }
            }
            return fileArr;
        }

        fileArr = new File[ getClassData().getClasses().size() ];
        if ( !getClassData().getClasses().isEmpty() ) {
            int ctr = 0;
            for ( String clsName : getClassData().getClasses().keySet() ) {
                String filePathName = javaPath.trim() + File.separator + clsName
                                      + ( sourceOrClass ? ".java" : ".class" );
                fileArr[ ctr++ ] = new File( filePathName );
            }
        }
        return fileArr;
    }

    public static JSONObject
           propertyToJSON( PropertyDecl p,
                           Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject property = new JSONObject();
        property.put( "name", p.name() );
        property.put( "type", p.ty().toString() );
        Tuple2< Object, Object > numbers = map.get( p );

        property.put( "line", numbers._1() );
        property.put( "char", numbers._2() );

        property.put( "children", new JSONArray() );

        return property;
    }

    public static JSONObject
           functionToJSON( FunDecl f,
                           Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject function = new JSONObject();
        function.put( "name", f.ident() );
        function.put( "type", "function" );
        Tuple2< Object, Object > numbers = map.get( f );
        function.put( "line", numbers._1() );
        function.put( "char", numbers._2() );
        function.put( "children", new JSONArray() );

        return function;
    }

    public static JSONObject
           entityToJSON( EntityDecl e,
                         Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject entity = new JSONObject();
        entity.put( "name", e.ident() );
        entity.put( "type", "class" );
        Tuple2< Object, Object > numbers = map.get( e );
        entity.put( "line", numbers._1() );
        entity.put( "char", numbers._2() );
        JSONArray children = new JSONArray();
        List< PropertyDecl > properties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( e.getPropertyDeclsNoIgnore() ) );
        for ( PropertyDecl p : properties ) {
            children.put( propertyToJSON( p, map ) );
        }
        List< FunDecl > functions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( e.getFunDecls() ) );
        for ( FunDecl f : functions ) {
            children.put( functionToJSON( f, map ) );
        }

        List< ConstraintDecl > constraints =
                new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( e.getConstraintDecls() ) );
        for ( ConstraintDecl c : constraints ) {
            JSONObject constraint = constraintToJSON( c, map );
            if ( constraint != null ) {
                children.put( constraint );
            }
        }

        List< EntityDecl > entities =
                new ArrayList< EntityDecl >( JavaConversions.asJavaCollection( e.getEntityDecls() ) );
        for ( EntityDecl ent : entities ) {
            JSONObject entJSON = entityToJSON( ent, map );
            if ( entJSON != null ) {
                children.put( entJSON );
            }
        }

        entity.put( "children", children );

        return entity;
    }

    public static JSONObject
           constraintToJSON( ConstraintDecl c,
                             Map< MemberDecl, Tuple2< Object, Object > > map ) {
        if ( c.name().isEmpty() ) {
            return null;
        }
        JSONObject constraint = new JSONObject();
        constraint.put( "name", c.name().get() );
        constraint.put( "type", "req" );
        Tuple2< Object, Object > numbers = map.get( c );

        constraint.put( "line", numbers._1() );
        constraint.put( "char", numbers._2() );

        constraint.put( "children", new JSONArray() );
        return constraint;
    }

    public static JSONObject kToContainmentTree( String k ) {
        return kToContainmentTree(k, null);
    }
    public static JSONObject kToContainmentTree( String k, Model m ) {
        if ( m == null ) {
            m = Frontend.lastParsedModel();
            if ( m == null ) {
                // stdout and stderr are not suppressed here
                m = Frontend.getModelFromString(k);
            }
        }
        Map< MemberDecl, Tuple2< Object, Object > > map =
                JavaConversions.mapAsJavaMap( Frontend.getLastDeclDict( k ) );
        JSONObject tree = new JSONObject();
        JSONArray topDecls = new JSONArray();
        if ( m == null ) {
            tree.put( "tree", topDecls );
            return tree;
        }
        List< EntityDecl > entities =
                new ArrayList< EntityDecl >( JavaConversions.asJavaCollection( Frontend.getEntitiesFromModel( m ) ) );
        List< PropertyDecl > properties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( m ) ) );
        List< FunDecl > functions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( m ) ) );
        List< ConstraintDecl > constraints =
                new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelConstraints( m ) ) );

        for ( EntityDecl e : entities ) {
            JSONObject entity = entityToJSON( e, map );
            topDecls.put( entity );
        }
        for ( FunDecl e : functions ) {
            JSONObject function = functionToJSON( e, map );
            topDecls.put( function );
        }

        for ( ConstraintDecl c : constraints ) {
            JSONObject constraint = constraintToJSON( c, map );
            if ( constraint != null ) {
                topDecls.put( constraint );
            }
        }

        for ( PropertyDecl p : properties ) {
            JSONObject property = propertyToJSON( p, map );
            topDecls.put( property );
        }

        tree.put( "tree", topDecls );
        return tree;
    }

    public static void main( String[] args ) {
        runMain(args);
    }
    public static KtoJava runMain( String[] args ) {
        String packageName = "generatedCode";
        String kToJavaOutLog = "kToJavaOut.log";
        String writeJavaOutLog = "writeJavaOut.log";
        String solutionLog = "solution.log";
        // System.setOut(new PrintStream(baosOut));
        // System.setErr(new PrintStream(baosErr));

        boolean solve = false;
        boolean containmentTree = false;
        boolean errorInfo = false;
        boolean translate = false;
        boolean runSMT = false;
        boolean verbose = false;
        boolean processStdoutAndStderr = true;

        JSONObject json = new JSONObject();  // This is now a member of KtoJava, so sync up with it!

        String kToExecute = "";
        ArrayList<String> kFileNames = new ArrayList<>();
        Boolean areFiles = args.length > 0;
        for ( int i = 0; i < args.length; ++i ) {
            String arg = args[ i ];
            if ( arg.contains( "package" ) ) {
                ++i;
                continue;
            }
            if ( !arg.contains( "--" ) && !FileUtils.exists( arg ) ) {
                areFiles = false;
                break;
            }
        }

        for ( int i = 0; i < args.length; ++i ) {
            String arg = args[ i ];
            if ( !arg.contains( "--" ) ) {
                if ( areFiles ) {
                    try {
                        String k;
                        k = FileUtils.fileToString( arg );
                        kToExecute += k + "\n";
                        kFileNames.add( arg );
                    } catch ( FileNotFoundException e ) {
                        e.printStackTrace();
                    }
                } else {
                    kToExecute += arg + " ";
                }
            } else {
                String a = arg.toLowerCase();
                if ( a.contains( "tree" ) ) {
                    containmentTree = true;
                } else if ( a.contains( "nosmt" ) ) {
                    runSMT = false;
                } else if ( a.contains( "smt" ) ) {
                    runSMT = true;
                } else if ( a.contains( "solve" ) ) {
                    solve = true;
                } else if ( a.contains( "error" ) ) {
                    errorInfo = true;
                } else if ( a.contains( "verbose" ) ) {
                    verbose = true;
                }
                // look for any of these: '--captureOff' '--noCapture'
                // '--capture off' '--capture=off' '--processOff' '--noProcess'
                // '--process off' '--process=off'
                else if ( a.contains( "capture" ) || a.contains( "process" ) ) {
                    if ( a.contains( "no" ) || a.contains( "off" ) ) {
                        processStdoutAndStderr = false;
                    } else if ( i < args.length - 1 ) {
                        a = args[ i + 1 ].toLowerCase();
                        if ( !a.startsWith( "-" )
                             && ( a.contains( "no" )
                                  || a.contains( "off" ) ) ) {
                            processStdoutAndStderr = false;
                            ++i;
                        }
                    }
                } else if ( a.contains( "package" ) ) {
                    packageName = args[ ++i ];
                }
            }
        }

        if ( solve || runSMT ) {
            errorInfo = true;
            //translate = true;
            containmentTree = true;
        }
        if ( !containmentTree && !errorInfo && !runSMT && !solve ) {
            containmentTree = true;
            //translate = true;
            errorInfo = true;
            runSMT = true;
            solve = true;
        }


        KtoJava kToJava = null;
        String targetDirectory = EventXmlToJava.generatedCodeLocation + File.separator + packageName;

        if ( errorInfo ) {
            // KtoJava kToJava = new KtoJava( kToExecute, packageName, translate
            // );
            final String kToExecuteC = kToExecute;
            final String packageNameC = packageName;
            final boolean translateC = translate;
            final boolean solveC = solve;
            final boolean errorInfoC = errorInfo;
            final boolean containmentTreeC = containmentTree;
            final boolean verboseC = verbose;
            final boolean runSmtC = runSMT;

            // These are defaults that may need to be overridden in the K model.
            Timepoint.setUnits("milliseconds");
            Timepoint.setEpoch("2020-001T00:00:00.000");
            Timepoint.setHorizonDuration(Timepoint.days(365.0));

            if ( !processStdoutAndStderr ) {
                try {
                    kToJava = new KtoJava(kToExecuteC, packageNameC, translateC, processStdoutAndStderr);
                    kToJava.kFiles = kFileNames;
                    kToJava.translateOrRunSmt(runSmtC, !translateC && solveC);
                    json = kToJava.json;
                } catch( Throwable t) {
                    t.printStackTrace();
                }
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        System.out.println("packageName = " + packageNameC);
                        System.out.println("runSMT = " + runSmtC);
                        System.out.println("solve = " + solveC);
                        System.out.println("errorInfo = " + errorInfoC);
                        System.out.println("containmentTree = " + containmentTreeC);
                        System.out.println("translate = " + translateC);
                        System.out.println("verbose = " + verboseC);

                        try {
                            KtoJava kToJava = new KtoJava( kToExecuteC, packageNameC,
                                                translateC, true );
                            kToJava.translateOrRunSmt(runSmtC, !translateC && solveC);
                            return kToJava;
                        } catch ( Throwable t ) {
                            t.printStackTrace();
                        }
                        return null;
                    }
                };
                String out = c.baosOut.toString();
                String err = c.baosErr.toString();
                if ( verbose ) {
                    System.err.println( err );
                    System.out.println( out );
                }
                kToJava = (KtoJava)c.result;
                if ( kToJava == null ) {
                    targetDirectory = EventXmlToJava.generatedCodeLocation + File.separator + packageName;
                } else {

                    json = kToJava.json;
                    targetDirectory = kToJava.getPackageSourcePath(null);
                }
                File d = new File( targetDirectory );
                d.mkdirs();
                String path = targetDirectory + File.separator + kToJavaOutLog;
                FileUtils.stringToFile( out, path );
                File f = new File( path );
                json.put( "kToJavaOutFile", f.getAbsolutePath() );

                // Add errors to JSON
                JSONArray jarr = new JSONArray();
                jarr.put( err );
                json.put( "errors", jarr );

                // Syntax errors not working? Just gives line:col.
                if ( false ) {
                    List< String > syntaxErrorList = syntaxErrors( c.baosErr );
                    String syntaxErrors = String.join( ",", syntaxErrorList );
                    // System.out.println( "===ERRORS===" );

                    StringBuffer sb = new StringBuffer();

                    sb.append( "Syntax Errors: "
                               + ( syntaxErrors.isEmpty() ? "None"
                                                          : syntaxErrors )
                               + "\n" );
                    // Add syntax errors to JSON
                    // if ( !syntaxErrorList.isEmpty() ) {
                    jarr = new JSONArray();
                    for ( String se : syntaxErrorList ) {
                        jarr.put( se );
                    }
                    json.put( "syntaxErrors", jarr );
                    // }
                    if ( !kToJava.typeCheckSucceeded ) {
                        sb.append( "Input k did not type check\n" );
                    }
                    if ( verbose ) {
                        System.out.println( sb.toString() );
                    }
                }
            }

        }
        if ( (translate || solve) && kToJava != null ) {
            final KtoJava k2j = kToJava;
            if ( !processStdoutAndStderr ) {
                k2j.writeFiles( null );
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        k2j.writeFiles( null );
                        return null;
                    }
                };
                JSONArray jarr =
                        json.has( "errors" ) ? json.getJSONArray( "errors" )
                                             : null;
                if ( jarr == null ) jarr = new JSONArray();
                if ( verbose ) {
                    System.err.println( c.baosErr.toString() );
                    System.out.println( c.baosErr.toString() );
                }
                jarr.put( c.baosErr.toString() );
                json.put( "errors", jarr );
                String outWrite = c.baosOut.toString();
                String path =
                        targetDirectory + File.separator + writeJavaOutLog;
                FileUtils.stringToFile( outWrite, path );
                File f = new File( path );
                json.put( "writeJavaOutFile", f.getAbsolutePath() );
            }
        }

        if ( kToJava != null && kToJava.tryingToCompileAndLoadInPlace && solve ) {
            final KtoJava k2j = kToJava;
            if ( !processStdoutAndStderr ) {
                k2j.compileLoadAndRun();
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        return k2j.compileAndLoad();

                    }
                };
                JSONArray jarr =
                        json.has( "errors" ) ? json.getJSONArray( "errors" )
                                             : null;
                if ( jarr == null ) jarr = new JSONArray();
                if ( verbose ) {
                    System.err.println( c.baosErr.toString() );
                    System.out.println( c.baosErr.toString() );
                }
                jarr.put( c.baosErr.toString() );
                json.put( "errors", jarr );
                String outWrite = c.baosOut.toString();
                String path =
                        targetDirectory + File.separator + writeJavaOutLog;
                FileUtils.stringToFile( outWrite, path );
                File f = new File( path );
                json.put( "solve", f.getAbsolutePath() );

                CaptureStdoutStderr c2 = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        Pair<Boolean, Class<?>> p = ((Pair<Boolean, Class<?>>) c.result);
                        k2j.run(p);
                        return null;
                    }
                };
                outWrite = c2.baosOut.toString();
                path = targetDirectory + File.separator + solutionLog;
                try {
                    JSONObject j = new JSONObject(outWrite);
                    if ( j != null ) {
                        for(String key : JSONObject.getNames(j)) {
                            json.put(key, j.get(key));
                        }
                    }
                } catch( Throwable t ) {
                    json.put("badJson", outWrite);
                    //t.printStackTrace();
                    // ignore?
                }
                boolean succ = FileUtils.stringToFile( outWrite, path );
//                if ( succ ) {
//                    System.out.println("Wrote solution to " + path);
//                } else {
//                    System.out.println("Failed to write solution to " + path);
//                }
            }
        }
        if ( containmentTree ) {
            // System.out.println( "===TREE===" );
            JSONObject tree = new JSONObject();
            try {
                Model m = kToJava == null ? null : kToJava.model();
                tree = kToContainmentTree( kToExecute, m );
            } catch ( Throwable t ) {
                if ( verbose ) {
                    t.printStackTrace();
                }
                if ( !errorInfo ) {
                    JSONArray jarr =
                            json.has( "errors" ) ? json.getJSONArray( "errors" )
                                                 : null;
                    if ( jarr == null ) jarr = new JSONArray();
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    PrintWriter pw = new PrintWriter( baos );
                    t.printStackTrace( pw );
                    jarr.put( baos.toString() );
                    json.put( "errors", jarr );
                }
            }
            // System.out.println( tree.toString(4) );
            JSONArray jarr =
                    json.has( "tree" ) ? tree.getJSONArray( "tree" ) : null;
            if ( jarr != null ) {
                json.put( "tree", jarr );
            } else {
                json.put( "tree", tree );
            }

        }

        if ( kToJava != null && kToJava.json != json ) {
            System.err.println("WARNING! KtoJava.json is different than the one declared in main()!");
            kToJava.json = json;
        }

        if ( verbose ) {
            System.out.println( "JSON output:" );
        }
        System.out.println( json.toString( 4 ) );
        return kToJava;
    }

    public void translateOrRunSmt(boolean trySmt, boolean translateToJava) {
        boolean smtSucceeded = false;
        if ( trySmt && typeCheckSucceeded ) {
            smtSucceeded = runSMT();
        }
        if ( !smtSucceeded && translateToJava) {
            translatePackage();
        }
    }

    // Syntax errors not working? Just gives line:col.
    public static List< String > syntaxErrors( ByteArrayOutputStream baos ) {
        return syntaxErrors( baos.toString() );
    }

    public static List< String > syntaxErrors( String baosString ) {
        List< String > errors = new ArrayList< String >();
        Pattern errorPattern = Pattern.compile( "[0-9]+:[0-9]+" );
        Matcher m = errorPattern.matcher( baosString );
        while ( m.find() ) {
            errors.add( m.group( 0 ) );
        }

        return errors;

    }

    public DurativeEvent compileLoadAndRun() {
        String projectPath = null;
        String mainClassString = this.packageName + ".Main";
        Class<?> mainClass = null;
        try {
            mainClass = ClassUtils.classForName(mainClassString);
        } catch (ClassNotFoundException e) {
        }
        if ( mainClass == null ) {
            mainClass = ClassUtils.getClassForName("Main", null, this.packageName, true);
        }
        ClassData classData = this.getClassData();
        ClassLoader loader = this.getClass().getClassLoader();///kToJava
        JavaCompiler compiler =
                ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = (compiler == null ? null : compiler.getStandardFileManager(null, null, null) );

        Pair<Boolean, Object> pbo =
                EventXmlToJava.compileLoadAndRun(this.javaFiles, projectPath, this.packageName,
                                                 mainClass, classData, loader, fileManager);
        if ( pbo != null && pbo.second instanceof DurativeEvent ) {
            this.mainEvent = (DurativeEvent) pbo.second;
            return this.mainEvent;
        }
        return null;
    }

    public Pair<Boolean, Class<?>> compileAndLoad() {
        String projectPath = null;
        String mainClassString = this.packageName + ".Main";
        Class<?> mainClass = null;
        try {
            mainClass = ClassUtils.classForName(mainClassString);
        } catch (ClassNotFoundException e) {
        }
        if ( mainClass == null ) {
            mainClass = ClassUtils.getClassForName("Main", null, this.packageName, true);
        }
        ClassData classData = this.getClassData();
        ClassLoader loader = this.getClass().getClassLoader();///kToJava
        JavaCompiler compiler =
                ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = (compiler == null ? null : compiler.getStandardFileManager(null, null, null) );
        ClassLoader c = EventXmlToJava.getLoader();
        if (c == null) {
            c = loader;
        }

        return EventXmlToJava.compileAndLoad(javaFiles, projectPath, packageName, mainClass, classData, c, fileManager);
    }

    public DurativeEvent run(Pair<Boolean, Class<?>> p) {
        ClassLoader c = EventXmlToJava.getLoader();
        if (p != null && p.first != null) {

            boolean succ = ((Boolean)p.first).booleanValue();
            if (succ) {
                Class<?> mainClass = null;
                if (p.second != null) {
                    mainClass = (Class)p.second;
                }

                Pair<Boolean, Object> pbo = EventXmlToJava.runRun(c, mainClass);
                if ( pbo != null && pbo.second instanceof DurativeEvent ) {
                    this.mainEvent = (DurativeEvent) pbo.second;
                    return this.mainEvent;
                }
            }
        }
        return null;
    }
}
