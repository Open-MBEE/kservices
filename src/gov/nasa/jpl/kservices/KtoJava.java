package gov.nasa.jpl.kservices;

import com.microsoft.z3.BoolExpr;
import com.google.common.collect.ImmutableSet;
import com.google.common.reflect.ClassPath;
import org.apache.commons.lang3.reflect.MethodUtils;

import gov.nasa.jpl.ae.util.CaptureStdoutStderr;
import gov.nasa.jpl.ae.util.ClassData;
import gov.nasa.jpl.ae.util.distributions.DistributionHelper;
import java.util.List;
import gov.nasa.jpl.mbee.util.*;
import japa.parser.*;
//import japa.parser.ASTHelper;
import japa.parser.ASTParser;
import japa.parser.ParseException;
import japa.parser.ast.CompilationUnit;
import japa.parser.ast.ImportDeclaration;
import japa.parser.ast.PackageDeclaration;
import japa.parser.ast.body.ClassOrInterfaceDeclaration;
import japa.parser.ast.body.ConstructorDeclaration;
import japa.parser.ast.body.FieldDeclaration;
import japa.parser.ast.body.MethodDeclaration;
import japa.parser.ast.body.ModifierSet;
import japa.parser.ast.body.TypeDeclaration;
import japa.parser.ast.body.VariableDeclarator;
import japa.parser.ast.body.VariableDeclaratorId;
import japa.parser.ast.expr.Expression;
import japa.parser.ast.expr.MethodCallExpr;
import japa.parser.ast.expr.NameExpr;
import japa.parser.ast.stmt.BlockStmt;
import japa.parser.ast.stmt.ExplicitConstructorInvocationStmt;
import japa.parser.ast.stmt.Statement;
import japa.parser.ast.stmt.TryStmt;
import japa.parser.ast.type.ClassOrInterfaceType;
import japa.parser.ast.type.PrimitiveType;
import japa.parser.ast.type.Type;
import japa.parser.ast.type.VoidType;
import k.frontend.*;
import scala.Tuple2;
import scala.collection.JavaConversions;

import java.io.*;
import java.util.*;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


// Keep these for resolving class references.
import gov.nasa.jpl.ae.xml.EventXmlToJava;

import org.json.JSONArray;
import org.json.JSONObject;

// import gov.nasa.jpl.kservices.scala.AeKUtil;

import gov.nasa.jpl.ae.util.JavaToConstraintExpression;

import javax.tools.JavaCompiler;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

/*
 * Translates XML to executable Java classes for Analysis Engine behavior
 */

public class KtoJava {

    protected boolean tryingToCompileAndLoadInPlace = true;

    protected String k;
    protected String packageName;
    protected Map<String, JavaToConstraintExpression> expressionTranslators;
    protected String smtOutput = null;
    protected HashMap<String, ArrayList<String>> smtTopObjects;
    protected HashMap<String, ArrayList<String>> smtExtraObjects;

    protected int constraintCounter;
    protected int expressionCounter;
    protected TypeChecker typeChecker;
    public boolean typeCheckSucceeded = false;
    protected Map<String, Model> models = new LinkedHashMap<String, Model>();
    protected ArrayList<Model> packageModels = new ArrayList<Model>();
    protected final String globalName;
    protected final String autoGenerated;
    protected Set< EntityDecl > allClasses;
    protected Set< EntityDecl > topLevelClasses;
    protected Set< String > allClassNames;
    protected Set< String > topLevelClassNames;
    protected Set< String > instantiatedClassNames;
    protected Map< String, Set< String > > classToParentNames;

    protected ArrayList<String> javaFiles = new ArrayList<String>();

    static protected DistributionHelper dh = new DistributionHelper();


    protected JSONObject json = new JSONObject();

    //boolean containmentTree = false;
    //boolean errorInfo = false;
    //boolean translate = false;
    protected boolean verbose = false;
    protected boolean processStdoutAndStderr = true;
    protected boolean allInitsAreConstraints = true;
    protected boolean smtSolved = false;

    //private ImmutableSet

    public KtoJava( String k, String pkgName, boolean translate, boolean processStdoutAndStderr ) {
        this.globalName = "Global";
        this.autoGenerated = "AutoGenerated";
        this.k = k;
        this.processStdoutAndStderr = processStdoutAndStderr;
        //if ( pkgName != null && !pkgName.equals( "" ) ) {
            this.packageName = pkgName;
        //} else {
        //    this.packageName = "";
        //}
        // Debug.turnOn();
        this.constraintCounter = 0;
        this.expressionCounter = 0;
        this.expressionTranslators = new HashMap<String, JavaToConstraintExpression>();
                //new JavaToConstraintExpression( packageName );

        if ( verbose ) {
            System.out.println();
        }
        // Parse!
        Model m = getModelFromString();
        if ( m == null || m.decls() == null || m.decls().isEmpty() ) return;
//        if ( !modelHasDeclsOutsidePackages( m ) ) {
//            this.packageName = "";
//        } else {
//            if ( !Utils.isNullOrEmpty( m.packageName().get() ) ) {
//                this.packageName =  m.packageName().get();
//            } else if ( m.packages() != null && !m.packages().isEmpty() ) {
////                this.packageName = m.packageName().get();
////                if ( this.packageName == null ) {
//                    this.packageName = "";
////                }
//            }
//            // else use the package name assigned from the constructor argument.
//        }
        setModel(m);
        // Type check!
        typeCheckSucceeded = typeCheck();

        init( translate );
    }

    public static boolean modelHasDeclsOutsidePackages( Model model ) {
        if ( model == null ) return false;
        if ( model.decls() == null ) return false;
        for ( TopDecl d : JavaConversions.asJavaCollection( model.decls() ) ) {
            if ( d instanceof PackageDecl ) continue;
            return true;
        }
        return false;
    }

    public void determineActualPackageName(Model m) {
        if ( m == null ) {
            Debug.error(true, false, "Warning! Trying to set model to null!");
            return;
        }
        boolean hasDecls = m.decls() != null && !m.decls().isEmpty();
        if ( !modelHasDeclsOutsidePackages( m ) ) {
            this.packageName = "";
        } else {
            scala.Option<String> x = scala.Option.apply(null);
            if ( m.packageName() != x && !Utils.isNullOrEmpty( m.packageName().get() ) ) {
                this.packageName =  m.packageName().get();
            } else if ( m.packages() != null && !m.packages().isEmpty() ) {
//                this.packageName = m.packageName().get();
//                if ( this.packageName == null ) {
                this.packageName = "";
//                }
            }
            // else use the package name assigned from the constructor argument.
        }

//        //if ( packageName == null ) packageName = "";
//        String packageName = this.packageName;
//        if ( m.packageName() != null && m.packageName().get() != null ) {
//            packageName = m.packageName().get();
//        }
//        if ( packageName == null ) packageName = "";
//        this.packageName = packageName;
        if ( this.packageName == null ) {
            this.packageName = "";
        }
    }

    public void setModel(Model m) {
        determineActualPackageName(m);
        models.put(this.packageName, m);
    }

    public void init(boolean translate) {
        // Collect declaration info
        this.topLevelClasses = getTopLevelClasses();
        this.allClasses = getAllClasses();
        this.allClassNames = new TreeSet< String >();
        this.topLevelClassNames = new TreeSet< String >();
        this.classToParentNames = new TreeMap< String, Set< String > >();
        // FIXME -- Why are we traversing lists that are guaranteed to be empty.  Should these be somwwhere else?
        for ( EntityDecl e : topLevelClasses ) {
            this.topLevelClassNames.add( e.ident() );
        }
        for ( EntityDecl e : allClasses ) {
            this.allClassNames.add( e.ident() );
            this.classToParentNames.put( e.ident(),
                                         new TreeSet< String >( JavaConversions.asJavaCollection( e.getExtendingNames() ) ) );

        }
        for ( String e : allClassNames ) {
            getAllSuperClassNames( e );
        }

        this.instantiatedClassNames = new TreeSet< String >();
        buildNestingTable( getClassData().getNestedToEnclosingClassNames() );
        buildParamTable( getClassData().getParamTable() );
        buildMethodTable( getClassData().getMethodTable() );

        // Translate to Java
        if ( translate ) {
            translatePackage();
        }
    }

    public KtoJava( String k, String pkgName, boolean processStdoutAndStderr ) {
        this( k, pkgName, false, processStdoutAndStderr );
    }

    public JavaToConstraintExpression expressionTranslator() {
        return expressionTranslator(this.packageName);
    }
    public JavaToConstraintExpression expressionTranslator(String packageName) {
        JavaToConstraintExpression e = expressionTranslators.get(packageName);
        if ( e == null ) {
            e = new JavaToConstraintExpression( packageName );
            expressionTranslators.put(packageName, e);
        }
        return e;
    }

    public static Model findModelForPackageInModel(String packageName, Model model) {
        if ( packageName == null ) return null;
        if ( packageName.equals(model.packageName().get()) ) {
            return model;
        }
        for ( PackageDecl p : JavaConversions.asJavaCollection( model.packages() ) ) {
            if ( packageName.equals( p.name().toString() ) ) {
                return model;
            }
            if ( packageName.startsWith(p.name().toString()) ) {
                Model m = findModelForPackageInModel(packageName, p.model());
                if ( m != null ) return m;
            }
        }
        return null;
    }

    public Model model() {
        return model(this.packageName);
    }
    public Model model(String packageName) {
        Model m = models.get(packageName);
        if ( m == null && !packageName.equals(this.packageName)) {
            Model model = model(this.packageName);
            if ( model != null ) {
                m = findModelForPackageInModel(packageName, model);
                if ( m != null ) {
                    models.put(packageName, m);
                }
            }
        }
        return m;
    }

    public boolean runSMT() {
        smtSolved = false;
        if(typeCheckSucceeded){
            try {
                //             K2Z3.solveSMT(this.model, this.model.toSMT(), true);
                BoolExpr boolExp = K2Z3.ctx().parseSMTLIB2String(this.model().toSMT(), null, null, null, null);
                com.microsoft.z3.Model z3Model = K2Z3.SolveExp(boolExp, this.model().toSMT());
                this.smtSolved = z3Model != null && com.microsoft.z3.Status.SATISFIABLE == K2Z3.solver().check();
                CaptureStdoutStderr stdoutStderr = new CaptureStdoutStderr() {
                    @Override public Object run() {
                        K2Z3.PrintModel(KtoJava.this.model());
                        return null;
                    }
                };

                this.smtOutput = stdoutStderr.baosOut.toString();
////                System.out.println(z3Model.toString());
                System.out.println(this.smtOutput);
                this.json.put("solveOutput", this.smtOutput);
            } catch (Throwable e) {
                System.out.println(e.getMessage());
            }
        }
        return smtSolved;
    }

    public Model getModelFromString() {
        if ( !processStdoutAndStderr ) {
            Model m = Frontend.getModelFromString(this.k);
            setModel(m);
        } else {
            CaptureStdoutStderr c = new CaptureStdoutStderr() {
                @Override
                public Object run() {
                    Model m = Frontend.getModelFromString(KtoJava.this.k);
                    setModel(m);
                    return null;
                }
            };
            String err = c.baosErr.toString();
            String out = c.baosOut.toString();
            String[] parseErrors = err.split("\n");
            JSONArray jarr = json.has("parseErrors") ? json.getJSONArray("parseErrors") : new JSONArray();
            for ( String str : parseErrors ) {
                jarr.put(str);
            }
            //jarr.put(Utils.arrayAsList(parseErrors));  // This deosn't work!
            json.put("parseErrors", jarr);
            //if ( verbose ) {
                System.err.println(err);
                System.out.println(out);
            //}
        }
        System.out.println();
        return this.model();
    }


    public boolean typeCheckForReal() {
        try {
            typeChecker = new TypeChecker(this.model());
            typeCheckSucceeded = true;
        } catch (Throwable e) {
            typeCheckSucceeded = false;
            System.err.println("Input did not Type Check");
            e.printStackTrace();
        }
        return typeCheckSucceeded;
    }
    public boolean typeCheck() {
        if (!processStdoutAndStderr) {
            typeCheckSucceeded = typeCheckForReal();
        } else {
            CaptureStdoutStderr c = new CaptureStdoutStderr() {
                @Override
                public Object run() {
                    return typeCheckForReal();
                }
            };
            String err = c.baosErr.toString();
            String out = c.baosOut.toString();
            String[] typeCheckErrors = err.split("\n");
            JSONArray jarr = json.has("typeCheckErrors") ? json.getJSONArray("typeCheckErrors") : new JSONArray();
            for ( String str : typeCheckErrors ) {
                jarr.put(str);
            }
            //jarr.put(Utils.arrayAsList(typeCheckErrors));  // This deosn't work!
            json.put("typeCheckErrors", jarr);
            //if ( verbose ) {
                System.err.println(err);
                System.out.println(out);
            //}
        }
        return typeCheckSucceeded;
    }


    public Set< EntityDecl > getTopLevelClasses() {
        if ( Utils.isNullOrEmpty(topLevelClasses) ) {
            topLevelClasses = getTopLevelClasses(model());
        }
        return topLevelClasses;
    }

    public static Set< EntityDecl > getTopLevelClasses( Model model ) {
        Set< EntityDecl > topLevelClasses = new LinkedHashSet<EntityDecl>(
                JavaConversions.asJavaCollection(
                        Frontend.getEntitiesFromModel(model)));
        return topLevelClasses;
    }

    public Set< EntityDecl > getAllClasses() {
        return getAllClasses( model() );
    }
    public static Set< EntityDecl > getAllClasses(Model model) {
        Set< EntityDecl > allEntities = new LinkedHashSet< EntityDecl >();
        if ( model == null ) return allEntities;
        Set<EntityDecl> classes = getTopLevelClasses(model);
        if ( Utils.isNullOrEmpty(classes) ) return allEntities;
        Deque< EntityDecl > entitiesToGo =
                new ArrayDeque< EntityDecl >( classes );
        EntityDecl entity;
        while ( !entitiesToGo.isEmpty() ) {
            entity = entitiesToGo.pop();
            allEntities.add( entity );
            entitiesToGo.addAll( JavaConversions.asJavaCollection( entity.getEntityDecls() ) );
        }
        Collection<PackageDecl> pkgs = JavaConversions.asJavaCollection( model.packages() );
        if ( pkgs == null ) return allEntities;
        for ( PackageDecl p : pkgs ) {
            Model m = p.model();
            Set<EntityDecl> moreClasses = getAllClasses(m);
            if ( !Utils.isNullOrEmpty(moreClasses) ) {
                allEntities.addAll( moreClasses );
            }
        }
        return allEntities;
    }

    public void getAllSuperClassNames( String entityName ) {
        Set< String > extendingList = classToParentNames.get( entityName );
        if ( extendingList != null ) {
            for ( String e : extendingList ) {
                getAllSuperClassNames( e );
                Set< String > toAdd = classToParentNames.get( e );
                if ( toAdd != null ) {
                    extendingList.addAll( toAdd );
                }

            }
        }

    }

    public void buildNestingTable( Map< String, String > nestingTable ) {
        // true nested classes:
        for ( EntityDecl entity : this.allClasses ) {
            for ( EntityDecl innerEntity : JavaConversions.asJavaCollection( entity.getEntityDecls() ) ) {
                nestingTable.put( innerEntity.ident(), entity.ident() );
            }
        }

        for ( EntityDecl entity : this.allClasses ) {
            if ( !nestingTable.containsKey( entity.ident() ) ) {
                nestingTable.put( entity.ident(), globalName );
            }
        }
    }

    public void
           buildParamTable( Map< String, Map< String, ClassData.Param > > paramTable ) {
        Map< String, ClassData.Param > params =
                new TreeMap< String, ClassData.Param >();
        ClassData.Param param;
        addGlobalParams( paramTable );

        for ( EntityDecl entity : this.allClasses ) { // pass 1
            String entityName = getClassName( entity );
            params = new TreeMap< String, ClassData.Param >();
            ArrayList< PropertyDecl > propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDecls() ) );
            for ( PropertyDecl p : propertyList ) {
                param = makeParam( p, entity );
                String type = p.ty().toJavaString();
                if ( this.allClassNames.contains( type ) ) {
                    this.instantiatedClassNames.add( type );
                }
                params.put( p.name(), param );
            }
            ArrayList< FunDecl > funList =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
            for ( FunDecl funDecl : funList ) {
                Collection<Param> prms = JavaConversions.asJavaCollection(funDecl.params());
                List< Param > funParams = new ArrayList< Param >( prms );
                for ( Param p : funParams ) {
                    param = new ClassData.Param( p.name(),
                                                 JavaToConstraintExpression.typeToClass( p.ty()
                                                                                          .toJavaString() ),
                                                 null );
                    params.put( p.name(), param );
                }

            }
            paramTable.put( entityName, params );

        }
        for ( EntityDecl entity : this.allClasses ) { // pass 2
            String entityName = getClassName( entity );
            params = paramTable.get( entityName );
            Set< String > extendingList =
                    classToParentNames.get( entity.ident() );
            for ( String e : extendingList ) {
                Map< String, ClassData.Param > otherParams =
                        paramTable.get( getClassName( e ) );
                if ( otherParams != null ) {
                    params.putAll( otherParams );
                }

            }

        }

    }

    public void
           addGlobalParams( Map< String, Map< String, ClassData.Param > > paramTable ) {
        ClassData.Param param;
        Map< String, ClassData.Param > params =
                new TreeMap< String, ClassData.Param >();
        List< PropertyDecl > topLevelProperties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
        List< FunDecl > topLevelFunctions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        for ( PropertyDecl p : topLevelProperties ) {
            param = makeParam( p, null );
            String type = p.ty().toJavaString();
            if ( this.allClassNames.contains( type ) ) {
                this.instantiatedClassNames.add( type );
            }
            params.put( p.name(), param );
        }
        for ( FunDecl funDecl : topLevelFunctions ) {
            List< Param > funParams =
                    new ArrayList< Param >( JavaConversions.asJavaCollection( funDecl.params() ) );
            for ( Param p : funParams ) {
                param = new ClassData.Param( p.name(),
                                             JavaToConstraintExpression.typeToClass( p.ty()
                                                                                      .toJavaString() ),
                                             null );
                params.put( p.name(), param );
            }
        }

        paramTable.put( globalName, params );

    }

    public void
           buildMethodTable( Map< String, Map< String, Set< MethodDeclaration > > > methodTable ) {
        addGlobalMethods( methodTable );
        for ( EntityDecl entity : this.allClasses ) {
            String entityName = getClassName( entity );

            Map< String, Set< MethodDeclaration > > classMethods =
                    methodTable.get( entityName );

            if ( classMethods == null ) {
                classMethods =
                        new TreeMap< String, Set< MethodDeclaration > >();
                methodTable.put( entityName, classMethods );
            }
            Collection< MethodDeclaration > methodCollection =
                    getMethods( entity );

            for ( MethodDeclaration methodDecl : methodCollection ) {
                Set< MethodDeclaration > methodSet =
                        classMethods.get( methodDecl.getName() );
                if ( methodSet == null ) {
                    methodSet =
                            new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
                    classMethods.put( methodDecl.getName(), methodSet );
                }
                methodSet.add( methodDecl );
            }

        }
    }

    public void
           addGlobalMethods( Map< String, Map< String, Set< MethodDeclaration > > > methodTable ) {
        List< FunDecl > topLevelFunctions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        Map< String, Set< MethodDeclaration > > classMethods =
                new TreeMap< String, Set< MethodDeclaration > >();
        methodTable.put( globalName, classMethods );
        Collection< MethodDeclaration > methodCollection = getMethods( null );
        for ( MethodDeclaration methodDecl : methodCollection ) {
            Set< MethodDeclaration > methodSet =
                    classMethods.get( methodDecl.getName() );
            if ( methodSet == null ) {
                methodSet =
                        new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
                classMethods.put( methodDecl.getName(), methodSet );
            }
            methodSet.add( methodDecl );
        }

    }

    // Delete this!  We're looking for a call not a declaration!
//    public boolean isElaboratesMethod( MethodDeclaration m ) {
//        if ( m == null ) return false;
//        if ( !m.getName().equals("elaborates") ) return false;
//        if ( m.getParameters() == null ) return false;
//        if ( m.getParameters().size() < 2 ) return false;
//        if ( m.)
//        return true;
//    }

    public Collection< MethodDeclaration > getMethods( EntityDecl entity ) {
        ArrayList< MethodDeclaration > methodDeclarations =
                new ArrayList< MethodDeclaration >();
        ArrayList< FunDecl > functions;
        if ( entity != null ) {
            functions =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
        } else {
            functions =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        }

        for ( FunDecl funDecl : functions ) {
            MethodDeclaration methodDecl = makeMethodDecl( funDecl );
            if ( methodDecl != null ) {
                methodDeclarations.add( methodDecl );
            }
        }
        return methodDeclarations;

    }

    public MethodDeclaration makeMethodDecl( FunDecl funDecl ) {
        MethodDeclaration methodDecl = new MethodDeclaration();
        String typeString =
                JavaToConstraintExpression.typeToClass( funDecl.ty().get()
                                                               .toJavaString() );
        methodDecl.setType( new ClassOrInterfaceType( "Expression<" + typeString
                                                      + ">" ) );
        methodDecl.setModifiers( 1 );
        methodDecl.setName( funDecl.ident() );
        List< Param > funParams =
                new ArrayList< Param >( JavaConversions.asJavaCollection( funDecl.params() ) );
        List< japa.parser.ast.body.Parameter > params =
                new ArrayList< japa.parser.ast.body.Parameter >();
        japa.parser.ast.body.Parameter param;
        for ( Param p : funParams ) {
            param = ASTHelper.createParameter( makeType( p.ty().toJavaString() ),
                                               p.name() );
            params.add( param );
        }
        methodDecl.setParameters( params );
        if ( funDecl.body().isEmpty() ) { // in the case where a method is
            // declared but not defined, not sure
            // if this is the best thing to do
            return null;
        }
        methodDecl.setThrows( Arrays.asList( new NameExpr( "Exception" ) ) );

        return methodDecl;
    }

    public Type makeType( String typeString ) {
        Type type;
        switch ( typeString ) {
            case "Int":
                type = new PrimitiveType( PrimitiveType.Primitive.Int );
                break;
            case "Bool":
                type = new PrimitiveType( PrimitiveType.Primitive.Boolean );
                break;
            case "Real":
                type = new PrimitiveType( PrimitiveType.Primitive.Double );
                break;
            default:
                type = new ClassOrInterfaceType( typeString );
        }
        return type;

    }

    public Boolean isPrimitive( String typeString ) {
        return typeString.equals( "Int" ) || typeString.equals( "Bool" )
               || typeString.equals( "Real" ) || typeString.equals( "String" );
    }

    public boolean isConstructorDecl( PropertyDecl p ) {
        String type =
                JavaToConstraintExpression.typeToClass( p.ty().toJavaString() );
        String value = p.expr().get().toJavaString();
        if ( value.startsWith( type + "(" ) ) {
            return true;
        }
        return false;
    }
    
    public String makeExpressionString(Exp exp) {
        if (exp instanceof CollectionEnumExp) {
            CollectionEnumExp collExp = (CollectionEnumExp)exp;
            StringBuffer sb = new StringBuffer();
            sb.append("new ");
            sb.append (collExp.kind().toJavaString());
            sb.append( "(Arrays.asList( ");
            ArrayList<Exp> args = new ArrayList<Exp>(JavaConversions.asJavaCollection( collExp.exps()));
            boolean first = true;
            for (Exp e : args) {
                String arg = makeExpressionString(e);
                if (!first) {
                    sb.append( "," + arg );
                } else {
                    first = false;
                    sb.append( arg );
                }
                
            }
            sb.append( " ))");
            return sb.toString();
            
        } else {
            if (exp == null) {
                int x = 1;
            }
            return exp.toJavaString();
        }
        
        
       
    }

    public ClassData.Param makeParam( PropertyDecl p, EntityDecl e ) {
        String name = p.name();
        String typeOld =
                JavaToConstraintExpression.typeToClass(p.ty().toJavaString());
        
        String type = typeOld;
        if ( e != null ) {
            // type = getClassName( type );
        }
        if ( ( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
               || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
               || typeOld.equals( "String" ) ) ) {
            type = typeOld;
        }
        String value;
        if ( p.expr().isEmpty() ) {
            value = "null";
            if ( !( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
                    || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
                    || typeOld.equals( "String" ) ) ) {
                value = "new " + type + "()";
            }
        } else {
            value = makeExpressionString(p.expr().get()); 
            if ( isConstructorDecl( p ) ) {
                value = "new " + value;
            }
        }
        return new ClassData.Param( name, type, value );
    }

    public ClassData.Param makeParam( PropertyDecl p, EntityDecl e,
                                      Boolean nullValue ) {
        if ( !nullValue ) {
            return makeParam( p, e );
        }

        String name = p.name();
        String typeOld =
                JavaToConstraintExpression.typeToClass( p.ty().toJavaString() );
        String type = typeOld;
        if ( e != null ) {
            // type = getClassName( type );
        }
        if ( ( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
               || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
               || typeOld.equals( "String" ) ) ) {
            type = typeOld;
        }
        String value;
        if ( p.expr().isEmpty() ) {
            value = "null";
            if ( !( typeOld.equals( "Boolean" ) || typeOld.equals( "Double" )
                    || typeOld.equals( "Integer" ) || typeOld.equals( "Long" )
                    || typeOld.equals( "String" ) ) ) {
                value = "new " + type + "()";
            }
        } else {
            value = "null";

        }
        return new ClassData.Param( name, type, value );

    }

    // REVIEW -- Does anything call this?
    public void translateExpression() {
        getClassData().setCurrentClass( "Main" );
        initClassCompilationUnit( getClassData().getCurrentClass() );

        ClassOrInterfaceDeclaration newClassDecl =
                new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                 getClassData().getCurrentClass() );
        ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                      newClassDecl );

        int mods = ModifierSet.PUBLIC | ModifierSet.STATIC;

        MethodDeclaration mainMethodDecl =
                new MethodDeclaration( mods, new VoidType(), "main" );
        BlockStmt mainBody = new BlockStmt();
        mainMethodDecl.setBody( mainBody );

        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt ctorBody = new BlockStmt();
        ctor.setBlock( ctorBody );

        Type type = ASTHelper.createReferenceType( "String", 1 );
        VariableDeclaratorId id = new VariableDeclaratorId( "args" );
        japa.parser.ast.body.Parameter parameter =
                new japa.parser.ast.body.Parameter( type, id );

        ASTHelper.addParameter( mainMethodDecl, parameter );
        ASTHelper.addMember( newClassDecl, mainMethodDecl );

        StringBuffer stmtsMain = new StringBuffer();

        List< Expression > args = new ArrayList< Expression >();
        Expression expr = expressionTranslator().parseExpression( this.k );
        String aeString = expressionTranslator().astToAeExpr( expr, null, true,
                                                            true, false, true, true );
        stmtsMain.append( "Object value = " + aeString + ";" );
        stmtsMain.append( "System.out.println( value );" );
        ASTHelper.addStmt( ctorBody,
                           new ExplicitConstructorInvocationStmt( false, null,
                                                                  args ) );

        addImport( "gov.nasa.jpl.ae.event.Expression" );

        addStatements( mainBody, stmtsMain.toString() );

        String tryCatchString = "try{\n" + ";\n" + "} catch ( Exception e ) {\n"
                                + "  // TODO Auto-generated catch block\n"
                                + "  e.printStackTrace();\n" + "}\n";

        List< Statement > stmts = new ArrayList< Statement >();
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );

        TryStmt tryStmt = null;

        ASTParser parser = new ASTParser( new StringReader( tryCatchString ) );
        try {
            tryStmt = parser.TryStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
            return;
        }
        tryStmt.setTryBlock( mainBody );
        stmts.add( tryStmt );
        BlockStmt newBody = new BlockStmt( stmts );
        mainMethodDecl.setBody( newBody );

    }


    public void translatePackage() {
        // Translate current package
        translatePackage(this.packageName);
    }
    public void translatePackage( PackageDecl p ) {
        if ( p != null ) {
            Model model = p.model();
            String pName = p.name().toString();
            if ( pName == null ) pName = "";
            models.put( pName, model );
            translatePackage( pName );
        }
    }
    public void translatePackage( String packageName ) {
        this.packageName = packageName;

        // Save name
        String originalPackageName = packageName;
        
        // Initialize translation data for package
        Model m = model();
        if ( m == null ) return;
        JavaToConstraintExpression xlator = expressionTranslator();
        init( false );

        translateClasses();

        // recursively translate subpackages
        scala.collection.immutable.List<PackageDecl> pkgs = m.packages();
        if ( pkgs == null ) return;
        Collection< PackageDecl > packages = JavaConversions.asJavaCollection( pkgs );
        try {
            for (PackageDecl p : packages) {
                translatePackage(p);
            }
        } catch ( Throwable t ) {
            t.printStackTrace();
        } finally {
            //model = originalModel;
            packageName = originalPackageName;
        }
    }

    public void translateClasses() {
        // Translate class (and other?) declarations.
        processClassDeclarations( true );
        processClassDeclarations( false );
        addConstructors();
        processExecutionEvent();
    }


        /**
         * @return the expressionTranslator
         */
    public JavaToConstraintExpression getExpressionTranslator() {
        return expressionTranslator();
    }

    public ClassData getClassData() {
        JavaToConstraintExpression t = getExpressionTranslator();
        if ( Debug.errorOnNull( "Trying to get classData from null translator!",
                                t ) ) {
            return null;
        }
        return t.getClassData();
    }

    private void processClassDeclarations( boolean justClassDeclarations ) {
        processClassDeclarations( null, justClassDeclarations );
    }

    private void processClassDeclarations( EntityDecl entity,
                                           boolean justClassDeclarations ) {
        ClassOrInterfaceDeclaration classDecl;
        if ( justClassDeclarations ) {
            if ( entity == null ) {
                getClassData().setCurrentCompilationUnit( initClassCompilationUnit( globalName ) );
            }
            classDecl =
                    processClassDeclaration( entity, justClassDeclarations );
            ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                          classDecl );
        } else {
            processClassDeclaration( entity, justClassDeclarations );
        }
    }

    public String getClassName( EntityDecl entity ) {
        if ( entity == null ) {
            return globalName;
        } else {
            return getClassName( entity.ident() );
        }
    }

    public String getClassName( String entityName ) {
        if ( entityName != null ) {
            String className = entityName;
            entityName = getClassData().getNestedToEnclosingClassNames()
                                       .get( entityName );
            while ( entityName != null ) {
                className = entityName + "." + className;
                entityName = getClassData().getNestedToEnclosingClassNames()
                                           .get( entityName );
            }
            return className;
        } else {
            return globalName;
        }
    }

    public ClassOrInterfaceDeclaration
           processClassDeclaration( EntityDecl entity,
                                    boolean justClassDeclarations ) {

        Collection< EntityDecl > innerEntities;
        //Collection< PackageDecl > packages = JavaConversions.asJavaCollection( model.packages() );
        String enclosingIdent;
        Collection< ClassOrInterfaceDeclaration > innerClassDecls =
                new ArrayList< ClassOrInterfaceDeclaration >();

        if ( entity == null ) {
            innerEntities = this.topLevelClasses;
            enclosingIdent = globalName;
        } else {
            innerEntities =
                    JavaConversions.asJavaCollection( entity.getEntityDecls() );
            enclosingIdent = entity.ident();
        }

        for ( EntityDecl innerEntity : innerEntities ) {
            innerClassDecls.add( processClassDeclaration( innerEntity,
                                                          justClassDeclarations ) );
        }

        String currentClass = getClassName( entity );

        getClassData().setCurrentClass( currentClass );

        ClassOrInterfaceDeclaration newClassDecl = null;

        if ( justClassDeclarations ) {
            newClassDecl =
                    new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                     ClassUtils.simpleName( currentClass ) );

            getSuperClasses( entity, newClassDecl );
            createDefaultConstructor( newClassDecl );
        } else {
            // getClassData().setCurrentCompilationUnit(
            // getClassData().getClasses()
            // .get( currentClass ) );
            newClassDecl = getClassData().getClassDeclaration( currentClass ); // need
                                                                               // to
                                                                               // fix
            setMethodBodies( entity );
            createMembers( newClassDecl, entity );
        }

        if ( justClassDeclarations ) {
            for ( ClassOrInterfaceDeclaration innerClassDecl : innerClassDecls ) {
                ASTHelper.addMember( newClassDecl, innerClassDecl );
            }
        }

        return newClassDecl;

    }

    public void setMethodBodies( EntityDecl entity ) {
        List< FunDecl > funDecls;
        Map< String, Set< MethodDeclaration > > classMethods;
        if ( entity == null ) {
            classMethods = getClassData().getMethodTable().get( globalName );
            funDecls =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( this.model() ) ) );
        } else {
            String entityName = getClassName( entity );
            classMethods = getClassData().getMethodTable().get( entityName );
            funDecls =
                    new ArrayList< FunDecl >( JavaConversions.asJavaCollection( entity.getFunDecls() ) );
        }

        for ( FunDecl funDecl : funDecls ) {
            Set< MethodDeclaration > methodSet =
                    classMethods.get( funDecl.ident() );
            if ( methodSet != null ) {
                for ( MethodDeclaration methodDecl : methodSet ) {
                    BlockStmt body = new BlockStmt();
                    String typeString = funDecl.ty().get().toJavaString();
                    if ( !funDecl.body().isEmpty() ) {
                        Expression expr =
                                expressionTranslator().parseExpression( ( (ExpressionDecl)funDecl.body()
                                                                                               .apply( 0 ) ).exp()
                                                                                                            .toJavaString() );
                        String aeString =
                                expressionTranslator().astToAeExpr( expr,
                                                                  typeString,
                                                                  true, true,
                                                                  false,
                                                                  true, false );
                        addStatements( body, "return " + aeString + ";" );

                        methodDecl.setBody( body );
                    }
                }
            }

        }

    }

    protected void createDefaultConstructor( TypeDeclaration newClassDecl ) {
        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt block = new BlockStmt();
        ASTHelper.addStmt( block, new ExplicitConstructorInvocationStmt() );
        ctor.setBlock( block );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Members" ) );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Collections" ) );
        ASTHelper.addStmt( block,
                           new MethodCallExpr( null,
                                               "init" + newClassDecl.getName()
                                                     + "Dependencies" ) );

    }

    protected void getSuperClasses( EntityDecl entity,
                                    ClassOrInterfaceDeclaration newClassDecl ) {
        if ( entity == null ) {
            addExtends( newClassDecl, "DurativeEvent" );
            return;
        }
        List< ClassOrInterfaceType > extendsList = getInheritsFrom( entity );
        if ( !Utils.isNullOrEmpty( extendsList ) ) {
            newClassDecl.setExtends( extendsList );
        }
        if ( Utils.isNullOrEmpty( newClassDecl.getExtends() ) ) {
            addExtends( newClassDecl, "ParameterListenerImpl" );
        }
    }

    public List< ClassOrInterfaceType > getInheritsFrom( EntityDecl entity ) {

        // Need to figure out how to do multiple extends TODO
        // List< String > extendsStringList =
        // new ArrayList< String >( JavaConversions.asJavaCollection(
        // TypeChecker.getSuperClasses( entity.ident() ) ) );
        // List< ClassOrInterfaceType > extendsList =
        // new ArrayList< ClassOrInterfaceType >();
        // for ( String e : extendsStringList ) {
        // ClassOrInterfaceType c = new ClassOrInterfaceType( e );
        // extendsList.add( c );
        // }
        // return extendsList;
        // only do one for now
        List< k.frontend.Type > types =
                new ArrayList< k.frontend.Type >( JavaConversions.asJavaCollection( entity.extending() ) );
        if ( types.isEmpty() ) {
            return new ArrayList< ClassOrInterfaceType >();
        }
        k.frontend.Type type =
                new ArrayList< k.frontend.Type >( JavaConversions.asJavaCollection( entity.extending() ) ).get( 0 );
        return Arrays.asList( new ClassOrInterfaceType( type.toString() ) );
    }

    // right now assumes imports are java imports
    protected void getImports() {
        List< ImportDecl > imports =
                new ArrayList< ImportDecl >( JavaConversions.asJavaCollection( model().imports() ) );
        for ( ImportDecl imp : imports ) {
            addImport( imp.toStringNoImport() );
        }
    }
    // TODO

    public Set< MethodDeclaration > getMethodsForClass( String className ) {
        Map< String, Set< MethodDeclaration > > classMethods =
                getClassData().getMethodTable().get( className );
        if ( classMethods == null ) return ClassData.emptyMethodDeclarationSet;
        Set< MethodDeclaration > methodsForClass =
                new TreeSet< MethodDeclaration >( new CompareUtils.GenericComparator< MethodDeclaration >() );
        for ( Set< MethodDeclaration > methodsByName : classMethods.values() ) {
            methodsForClass.addAll( methodsByName );
        }
        return methodsForClass;
    }

    protected void createMembers( TypeDeclaration newClassDecl,
                                  EntityDecl entity ) {

        Collection< MethodDeclaration > methods =
                getMethodsForClass( getClassData().getCurrentClass() );
        for ( MethodDeclaration methodDecl : methods ) {

            ASTHelper.addMember( newClassDecl, methodDecl );
        }

        MethodDeclaration initMembers =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Members" );

        MethodDeclaration initElaborations =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Elaborations" );

        MethodDeclaration initDependencies =
                createPublicVoidMethod( "init" + newClassDecl.getName()
                                        + "Dependencies" );
        addStatements( initElaborations.getBody(),
                       "init" + newClassDecl.getName() + "Dependencies();" );

        List< FieldDeclaration > members = new ArrayList< FieldDeclaration >();
        Collection< FieldDeclaration > parameters =
                getParameters( entity, initMembers );
        Collection< FieldDeclaration > constraints =
                getConstraints( entity, initMembers );
        createEnclosingInstanceStatment( entity,initMembers );

        ArrayList<FieldDeclaration> effects = null;
          effects = getEffects( entity,
                                initMembers );
        Collection< FieldDeclaration > elaborations = null;
          elaborations =
              getElaborations( entity,
                               initElaborations );

        
        parameters.addAll( getExpressions( entity, initMembers ) );

        members.addAll( parameters );
        members.addAll( constraints );
        addTryCatchToInitMembers( initMembers );
        

        MethodDeclaration initCollections =
                createInitCollectionsMethod( "init" + newClassDecl.getName()
                                             + "Collections", parameters, constraints );

        // Add fields and methods to class declaration.
        for ( FieldDeclaration f : members ) {
            ASTHelper.addMember( newClassDecl, f );
        }
        ASTHelper.addMember( newClassDecl, initMembers );
        ASTHelper.addMember( newClassDecl, initCollections );
        ASTHelper.addMember( newClassDecl, initDependencies );

    }

    public ArrayList< FieldDeclaration >
           getParameters( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > parameters =
                new ArrayList< FieldDeclaration >();
        ArrayList< PropertyDecl > propertyList;
        FieldDeclaration f;
        if ( entity == null ) {
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
            // TODO: improve scope resolution and turn this back into
            // allClassNames version
            // for ( String className : allClassNames ) {
            for ( String className : topLevelClassNames ) {
                if ( !instantiatedClassNames.contains( className ) ) {
                    ClassData.Param p =
                            new ClassData.Param( autoGenerated + className,
                                                 className, null );
                    f = createParameterField( p, initMembers );
                    if ( f != null ) {
                        parameters.add( f );
                    }
                }
            }
        } else {
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDecls() ) );
        }

        for ( PropertyDecl property : propertyList ) {
            ClassData.Param p = makeParam( property, entity );
            f = createParameterField( p, initMembers );
            if ( f != null ) {
                parameters.add( f );
            }

        }

        return parameters;
    }

    public ArrayList< FieldDeclaration >
           getExpressions( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > parameters =
                new ArrayList< FieldDeclaration >();
        if ( entity == null ) {
            ArrayList< ExpressionDecl > expressionList =
                    new ArrayList< ExpressionDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelExpressions( this.model() ) ) );
            FieldDeclaration f;
            for ( ExpressionDecl expressionDecl : expressionList ) {
                Exp exp = expressionDecl.exp();
                String name = new String( "expression" + expressionCounter++ );
                // String type =
                // JavaToConstraintExpression.typeToClass(
                // TypeChecker.exp2Type()
                // .get( exp )
                // .toString() );
                String type = "Object";
                ClassData.Param p =
                        new ClassData.Param( name, type, exp.toJavaString() );
                f = createParameterField( p, initMembers );
                if ( f != null ) {
                    parameters.add( f );
                }

            }
        }

        return parameters;
    }

    public Collection< FieldDeclaration >
           getConstraints( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > constraints =
                new ArrayList< FieldDeclaration >();
        FieldDeclaration f;
        String expression;
        ArrayList< ConstraintDecl > constraintList;
        ArrayList< PropertyDecl > propertyList;
        if ( entity == null ) {
            constraintList =
                    new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelConstraints( this.model() ) ) );
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( this.model() ) ) );
        } else {
            constraintList =
                    new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( entity.getConstraintDecls() ) );
            propertyList =
                    new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( entity.getPropertyDecls() ) );
        }
        for ( ConstraintDecl constraint : constraintList ) {

            String name = constraint.name().isEmpty() ? null
                                                      : constraint.name().get();
            expression = makeExpressionString(constraint.exp());

            f = createConstraintField( name, expression, initMembers );
            if ( f != null ) {
                constraints.add( f );
            }

        }

        for ( PropertyDecl property : propertyList ) {

            if ( !property.expr().isEmpty()
                 && (allInitsAreConstraints || isPrimitive( property.ty().toJavaString() )) ) {
                expression = makeExpressionString(property.expr().get());
                f = createConstraintField( null,
                                           property.name() + " == (" + expression + ")",
                                           initMembers );
                if ( f != null ) {
                    constraints.add( f );
                }
            }
        }

        return constraints;

    }

    public ArrayList<FieldDeclaration>
    getEffects(EntityDecl entity, MethodDeclaration initMembers) {
        ArrayList<FieldDeclaration> effects =
                new ArrayList<FieldDeclaration>();
        //FieldDeclaration f;

        return effects;
    }

    public ArrayList< FieldDeclaration >
           getElaborations( EntityDecl entity, MethodDeclaration initMembers ) {
        ArrayList< FieldDeclaration > elaborations =
                new ArrayList< FieldDeclaration >();
        //FieldDeclaration f;

        
        return elaborations;
    }

    // Add constructors for invocations.
    protected void addConstructors() {
      Collection< ConstructorDeclaration > constructors = getConstructorDeclarations(this.model());
      Collection<? extends ConstructorDeclaration> moreConstructors =
                createConstructors(this.model(), constructors);
      if ( moreConstructors != null ) {
          constructors.addAll(moreConstructors);
      }

      EventXmlToJava.addConstructors( constructors, getClassData() );
    }
    
    protected Collection< ? extends ConstructorDeclaration >
            createConstructors( Model model2,
                                Collection< ConstructorDeclaration > constructors ) {
        // TODO Auto-generated method stub
        return null;
    }

    protected static void findElaborationExpressions(HasChildren elem, ArrayList< FunApplExp > elaborations, Seen<HasChildren> seen) {
        if ( elem == null ) return;
        Pair< Boolean, Seen<HasChildren>> p = Utils.seen(elem, true, seen );
        if ( p.first ) return;
        seen = p.second;
        if ( elem instanceof FunApplExp )  {
            FunApplExp fae = (FunApplExp) elem;
            if ( fae.name().equals("elaborates") ) {
                if ( fae.args() != null && JavaConversions.asJavaCollection(fae.args()).size() >= 2 ) {
                    elaborations.add(fae);
                }
            }
        }
        scala.collection.immutable.List<Object> children = elem.children();
        if (children == null) return;
        scala.collection.Iterator iter = children.iterator();
        while ( iter.hasNext() ) {
            Object o = iter.next();
            if ( o instanceof HasChildren ) {
                findElaborationExpressions( (HasChildren)o, elaborations, seen);
            }
        }
    }

    protected ConstructorDeclaration getConstructorDeclaration( FunApplExp fae ) {
        String eventType = null;
        String fromTimeVarying = null;
        List< ClassData.Param > arguments = new ArrayList<ClassData.Param>();
        scala.collection.Iterator iter = fae.args().iterator();
        //for ( Argument arg : fae.args() ) {
        int ct = 0;
        while (iter.hasNext() ) {
            Argument arg = (Argument)iter.next();
            String name = null;
            Exp exp = null;
            String paramName = null;
            if ( arg instanceof PositionalArgument) {
                PositionalArgument pa = (PositionalArgument)arg;
                exp = pa.exp();
            } else if  (arg instanceof NamedArgument ) {
                NamedArgument na = (NamedArgument)arg;
                exp = na.exp();
                paramName = na.ident();
            } else {
                Debug.error("Unrecognized argument: " + arg);
            }
            if ( exp instanceof DotExp ) {
                DotExp de = (DotExp)exp;
                name = de.toString();
            } else
            if ( exp instanceof ClassExp ) {
                k.frontend.Type type = ((ClassExp)exp).ty();
                if ( type instanceof ClassType ) {
                    QualifiedName n = ((ClassType)type).ident();
                    name = n.toString();
                } else if ( type instanceof IdentType ) {
                    QualifiedName n = ((IdentType) type).ident();
                    name = n.toString();
                } else {
                    // shouldn't be possible
                }
            } else
            if ( exp instanceof IdentExp ) {
                name = ((IdentExp) exp).ident();
            } else if ( exp instanceof NullLiteral$ ){
                name = null;
                //Debug.error("Got NullLiteral: " + exp );
//                    if (!( exp instanceof NullLiteral )) {
//                        name = exp.toString();
//                    }
            } else {
                Debug.error("Unexpected k expression type: " + exp.getClass().getCanonicalName() );
            }
//                    } else if ( exp instanceof ) {
//                        makeParam()
//                    }
            if (eventType == null &&
                    (paramName == null || paramName.toLowerCase().contains("event"))) {
                eventType = name;
            } else if ( fromTimeVarying == null  &&
                    (paramName == null || paramName.toLowerCase().contains("timevarying"))) {
                fromTimeVarying = name;
            }

            // Handle arguments passed through to initialize the Event.
            if ( eventType != null && ( fromTimeVarying != null || ct > 2 ) ) {
                // Make sure that both the name of the Parameter and the Expression are together.
                if ( iter.hasNext() ) {
                    Argument arg2 = (Argument)iter.next();
                    ClassData.Param param = new ClassData.Param(("" + arg2).replaceAll("\"", ""), (String)null, "" + arg);
                    arguments.add(param);
                }
            }

            ++ct;
        }
        ConstructorDeclaration ctor =
                EventXmlToJava.getConstructorDeclaration(eventType, fromTimeVarying,
                        arguments, expressionTranslator());
        return ctor;
    }

    protected Collection< ConstructorDeclaration >
            getConstructorDeclarations( Model model ) {
        ArrayList<ConstructorDeclaration> ctors = new ArrayList<ConstructorDeclaration>();
        ArrayList<FunApplExp> elaborationCalls = new ArrayList<FunApplExp>();
        findElaborationExpressions( model, elaborationCalls, null );
        for ( FunApplExp fae : elaborationCalls ) {
            ConstructorDeclaration ctor = getConstructorDeclaration(fae);
            ctors.add(ctor);
        }
        return ctors;
    }

//    protected ConstructorDeclaration getConstructorDeclaration(String eventType,
//                                                               String fromTimeVarying,
//                                                               List< ClassData.Param > arguments ) {
//        ConstructorDeclaration ctor =
//                new ConstructorDeclaration( ModifierSet.PUBLIC,
//                                            ClassUtils.simpleName(eventType) );
//        if ( Debug.isOn() ) Debug.outln("ctor ctord as " + ctor.getName() );
//        if ( !Utils.isNullOrEmpty( fromTimeVarying ) ) {
//            ClassData.Param p = new ClassData.Param("startTime", "Long", null);
//            arguments.add(p);
//            p = new ClassData.Param("duration", "Long", null);
//            arguments.add(p);
//        }
//        return ctor;
//    }

    public FieldDeclaration createConstraintField( String name,
                                                   String expression ) {

        if ( name == null ) {
            name = new String( "constraint" + constraintCounter++ );
        }

        String constructorArgs =
                expressionTranslator().javaToAeExpr( expression, "Boolean",
                                                   false );
        String constraintType = "ConstraintExpression";

        return createFieldOfGenericType( name, constraintType,
                                         constructorArgs );

    }

    // public String translateExpression(String expression) {
    //
    // }

    public FieldDeclaration
           createConstraintField( String name, String expression,
                                  MethodDeclaration initMembers ) {
        if ( initMembers == null ) {
            return createConstraintField( name, expression );
        }
        if ( name == null || name.trim().length() == 0 ) {
            name = new String( "constraint" + constraintCounter++ );
        }

        String constructorArgs =
                expressionTranslator().javaToAeExpr( expression, "Boolean",
                                                   true );
        // constructorArgs = "new Expression<Boolean>( \"" + expression +
        // "\", \"Java\" )";
        String constraintType = "ConstraintExpression";

        Statement s = createAssignmentOfGenericType( name, constraintType, null,
                                                     constructorArgs );
        ASTHelper.addStmt( initMembers.getBody(), s );

        FieldDeclaration f =  createFieldOfGenericType( name, constraintType, null, null );
        
        // deal with elaboration here?
        
        return f;
    }

    public FieldDeclaration createParameterField( ClassData.Param p ) {
        String args[] =
                expressionTranslator().convertToEventParameterTypeAndConstructorArgs( p );
        // return createFieldOfGenericType( p.name, type, p.type, args );
        return createFieldOfGenericType( p.name, args[ 0 ], null, // args[ 1 ],
                                         args[ 2 ] );
    }

    public FieldDeclaration
           createParameterField( ClassData.Param p,
                                 MethodDeclaration initMembers ) {
        if ( initMembers == null ) {
            return createParameterField( p );
        }
        String args[] =
                expressionTranslator().convertToEventParameterTypeAndConstructorArgs( p );
        Statement s = createAssignmentOfGenericType( p.name, args[ 0 ],
                                                     args[ 1 ], args[ 2 ] );
        ASTHelper.addStmt( initMembers.getBody(), s );
        FieldDeclaration f =
                createFieldOfGenericType( p.name, args[ 0 ], args[ 1 ], null );

        return f;
    }

    public void
           createEnclosingInstanceStatment( EntityDecl entity,
                                            MethodDeclaration initMembers ) {
        String entityName = null;
        if (entity != null) {
            entityName = entity.ident();
        }
        String enclosing = getClassData().getEnclosingClassName( entityName);
        if (enclosing != null) {
            String stmtString = "enclosingInstance = " + enclosing + ".this;";
            ASTParser parser = new ASTParser( new StringReader( stmtString ) );
            Statement stmt = null;
            try {
                stmt = parser.BlockStatement();
            } catch ( ParseException e ) {
                e.printStackTrace();
            }
            ASTHelper.addStmt( initMembers.getBody(), stmt );
        }
        

    }

    public static FieldDeclaration
           createFieldOfGenericType( String name, String typeName,
                                     String parameterTypeName,
                                     String constructorArgs ) {
        String fieldTypeName = typeName;
        if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
            fieldTypeName +=
                    "< " + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                             + " >";
        }
        ClassOrInterfaceType fieldType =
                new ClassOrInterfaceType( fieldTypeName );
        FieldDeclaration f = null;
        VariableDeclaratorId id = new VariableDeclaratorId( name );
        Expression init = null;
        String initValue = null;
        if ( constructorArgs == null ) {
            initValue = "null";
        } else {
            initValue = "new " + typeName;
            if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
                initValue +=
                        "< " + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                             + " >";
            }
            initValue += "( " + constructorArgs + " )";
        }
        init = new NameExpr( initValue );
        VariableDeclarator variable = new VariableDeclarator( id, init );
        f = ASTHelper.createFieldDeclaration( ModifierSet.PUBLIC, fieldType,
                                              variable );
        return f;
    }

    public static Statement
           createAssignmentOfGenericType( String name, String typeName,
                                          String parameterTypeName,
                                          String constructorArgs ) {
        StringBuffer stmtsString = new StringBuffer();
        stmtsString.append( "if ( " + name + " == null ) " );
        stmtsString.append( name + " = " );
        if ( constructorArgs == null ) {
            stmtsString.append( "null;" );
        } else {
            stmtsString.append( "new " + typeName );
            if ( !Utils.isNullOrEmpty( parameterTypeName ) ) {
                stmtsString.append( "< "
                                    + ClassUtils.getNonPrimitiveClassName( parameterTypeName )
                                    + " >" );
            }
            stmtsString.append( "( " + constructorArgs + " );" );
        }

        if ( Debug.isOn() ) Debug.outln( "Trying to parse assignment with ASTParser.BlockStatement(): \""
                                         + stmtsString.toString() + "\"" );
        ASTParser parser =
                new ASTParser( new StringReader( stmtsString.toString() ) );
        Statement stmt = null;
        try {
            stmt = parser.BlockStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
        }

        return stmt;
    }

    public static FieldDeclaration
           createFieldOfGenericType( String name, String typeName,
                                     String constructorArgs ) {
        return createFieldOfGenericType( name, typeName, null,
                                         constructorArgs );
    }

    protected MethodDeclaration createPublicVoidMethod( String methodName ) {
        MethodDeclaration initMembers =
                new MethodDeclaration( ModifierSet.PUBLIC, new VoidType(),
                                       methodName );
        initMembers.setBody( new BlockStmt() );
        return initMembers;
    }

    public static void addStatements( BlockStmt block, String stmts ) {
        addStatements( block, -1, stmts );
    }

    public static void addStatements( BlockStmt block, int pos, String stmts ) {
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );
        List< Statement > list = stringToStatementList( stmts );
        addStmts( block, pos, list );
    }

    private static void addStmts( BlockStmt block, List< Statement > list ) {
        addStmts( block, -1, list );
    }

    private static void addStmts( BlockStmt block, int pos,
                                  List< Statement > list ) {
        if ( list != null ) {
            if ( pos == -1 ) {
                if ( block == null
                     || Utils.isNullOrEmpty( block.getStmts() ) ) {
                    pos = 0;
                } else {
                    pos = block.getStmts().size();
                }
            }
            for ( Statement stmt : list ) {
                addStmt( block, pos++, stmt );
            }
        }
    }

    public static void addStmt( BlockStmt block, int pos, Statement stmt ) {
        List< Statement > stmts = block.getStmts();
        if ( stmts == null ) {
            stmts = new ArrayList< Statement >();
            block.setStmts( stmts );
        }
        if ( pos == -1 ) {
            stmts.add( stmt );
        } else {
            stmts.add( pos, stmt );
        }
    }

    public static List< Statement > stringToStatementList( String s ) {
        if ( Debug.isOn() ) Debug.outln( "trying to parse Java statements \""
                                         + s + "\"" );
        ASTParser parser = new ASTParser( new StringReader( s ) );
        List< Statement > stmtList = null;
        try {
            stmtList = parser.Statements();
        } catch ( Throwable e ) {
            System.err.println( "\nError parsing Java: \"" + s + "\"" );
            e.printStackTrace();
        }
        return stmtList;
    }

    protected void setPackage() {
        // set the package based on the xmlFileName
        // String packageName =
        // "generated."
        // + xmlFileName.substring( 0, xmlFileName.lastIndexOf( '.' ) )
        // .replaceAll( "[^A-Za-z0-9_]+", "_" );
        if ( Utils.isNullOrEmpty(packageName) ) return;
        if ( Debug.isOn() ) Debug.outln( "setting package for current compilation unit to "
                                         + packageName );
        getClassData().getCurrentCompilationUnit()
                      .setPackage( new PackageDeclaration( ASTHelper.createNameExpr( packageName ) ) );
    }

    private CompilationUnit initCompilationUnit( String name ) {
        getClassData().setCurrentCompilationUnit( new CompilationUnit() );
        getClassData().getClasses()
                      .put( ClassUtils.simpleName( name ),
                            getClassData().getCurrentCompilationUnit() );
        setPackage();
        return getClassData().getCurrentCompilationUnit();
    }

    private CompilationUnit initClassCompilationUnit( String name ) {
        getClassData().setCurrentCompilationUnit( initCompilationUnit( ClassUtils.simpleName( name ) ) );
        // REVIEW -- How can we access eclipse's ability to auto-remove unused
        // imports?
        // addImport( "gov.nasa.jpl.ae.event.*" );
        addImport( "gov.nasa.jpl.ae.event.Parameter" );
        addImport( "gov.nasa.jpl.ae.event.IntegerParameter" );
        addImport( "gov.nasa.jpl.ae.event.LongParameter" );
        addImport( "gov.nasa.jpl.ae.event.DoubleParameter" );
        addImport( "gov.nasa.jpl.ae.event.StringParameter" );
        addImport( "gov.nasa.jpl.ae.event.BooleanParameter" );
        addImport( "gov.nasa.jpl.ae.event.StateVariable" );
        addImport( "gov.nasa.jpl.ae.event.Timepoint" );
        addImport( "gov.nasa.jpl.ae.event.Expression" );
        addImport( "gov.nasa.jpl.ae.event.ConstraintExpression" );
        addImport( "gov.nasa.jpl.ae.event.Functions" );
        addImport( "gov.nasa.jpl.ae.event.FunctionCall" );
        addImport( "gov.nasa.jpl.ae.event.ConstructorCall" );
        addImport( "gov.nasa.jpl.ae.event.Call" );
        addImport( "gov.nasa.jpl.ae.event.Effect" );
        addImport( "gov.nasa.jpl.ae.event.EffectFunction" );
        addImport( "gov.nasa.jpl.ae.event.TimeDependentConstraintExpression" );
        addImport( "gov.nasa.jpl.ae.event.Dependency" );
        addImport( "gov.nasa.jpl.ae.event.ElaborationRule" );
        addImport( "gov.nasa.jpl.ae.event.EventInvocation" );
        addImport( "gov.nasa.jpl.ae.event.DurativeEvent" );
        addImport( "gov.nasa.jpl.ae.event.ParameterListenerImpl" );
        addImport( "gov.nasa.jpl.ae.event.TimeVaryingMap" );
        addImport( "gov.nasa.jpl.ae.event.Consumable" );
        addImport( "gov.nasa.jpl.ae.event.Timeline" );
        addImport( "gov.nasa.jpl.ae.event.TimeVaryingFunctionCall" );
        addImport( "gov.nasa.jpl.ae.event.Event" );
        addImport( "gov.nasa.jpl.ae.solver.ObjectDomain" );
        addImport( "gov.nasa.jpl.mbee.util.Utils" );
        addImport( "gov.nasa.jpl.mbee.util.Debug" );
        addImport( "gov.nasa.jpl.mbee.util.ClassUtils" );
        addImport( "java.util.Vector" );
        addImport( "java.util.Map" );
        addImport("java.util.ArrayList");
        addImport("java.util.Arrays");
        return getClassData().getCurrentCompilationUnit();
    }

    private void addImport( String impName ) {
        NameExpr ne = new NameExpr( impName );
        ImportDeclaration d = new ImportDeclaration( ne, false, false );
        if ( getClassData().getCurrentCompilationUnit().getImports() == null ) {
            getClassData().getCurrentCompilationUnit()
                          .setImports( new ArrayList< ImportDeclaration >() );
        }
        // check for duplicates -- REVIEW - inefficient linear search
        // TODO -- never finds duplicates!
        for ( ImportDeclaration i : getClassData().getCurrentCompilationUnit()
                                                  .getImports() ) {
            if ( i.getName().getName().equals( impName ) ) return;
        }
        getClassData().getCurrentCompilationUnit().getImports().add( d );
    }

    private void addTryCatchToInitMembers( MethodDeclaration initMembers ) {
        TryStmt tryStmt = null;

        // Need to add a statement that will certainly need all of these
        // exceptions;
        // otherwise, we'll get a compile error for trying to catch something
        // that
        // can't be thrown. Test code commented out below.
        String pkg = packageName + ".";
        if ( pkg.length() == 1 ) {
            pkg = "";
        }

        String tryCatchString = "try{\n" + ";\n" + "} catch ( Exception e ) {\n"
                                + "  // TODO Auto-generated catch block\n"
                                + "  e.printStackTrace();\n" + "}\n";

        List< Statement > stmts = new ArrayList< Statement >();
        if ( Debug.isOn() ) Debug.outln( "trying to parse \"" + stmts + "\"" );

        ASTParser parser = new ASTParser( new StringReader( tryCatchString ) );
        try {
            tryStmt = parser.TryStatement();
        } catch ( ParseException e ) {
            e.printStackTrace();
            return;
        }
        tryStmt.setTryBlock( initMembers.getBody() );
        stmts.add( tryStmt );
        BlockStmt newBody = new BlockStmt( stmts );
        initMembers.setBody( newBody );
    }

    private MethodDeclaration
            createInitCollectionsMethod( String methodName,
                                         Collection< FieldDeclaration > parameters,

                                         Collection< FieldDeclaration > constraints ) {
        MethodDeclaration initCollections =
                new MethodDeclaration( ModifierSet.PROTECTED, new VoidType(),
                                       methodName );
        // TODO -- Add initCollections()'s body.
        BlockStmt block = new BlockStmt();
        List< Statement > stmtList = null;
        stmtList = createStmtsFromFieldCollection( "parameters.add( ",
                                                   parameters, " );\n" );
        addStmts( block, stmtList );
        stmtList =
                createStmtsFromFieldCollection( "constraintExpressions.add( ",
                                                constraints, " );\n" );
        addStmts( block, stmtList );

        initCollections.setBody( block );
        return initCollections;
    }

    private List< Statement > createStmtsFromFieldCollection( String prefix,
                                                              Collection< FieldDeclaration > fieldCollection,
                                                              String suffix ) {
        if ( fieldCollection == null || fieldCollection.isEmpty() ) return null;
        // private Statement createInitCollectionStmt( String collectionName,
        // Collection< FieldDeclaration > fieldCollection ) {
        StringBuilder sb = new StringBuilder();
        for ( FieldDeclaration f : fieldCollection ) {
            // sb.append(" " + collectionName + ".add( " + f.getVariables().get(
            // 0
            // ) + " );\n" );
            sb.append( prefix + f.getVariables().get( 0 ).getId() + suffix );
        }
        return stringToStatementList( sb.toString() );
    }


    protected void processExecutionEvent() { 

        getClassData().setCurrentClass( "Main" );
        initClassCompilationUnit( getClassData().getCurrentClass() );

        ClassOrInterfaceDeclaration newClassDecl =
                new ClassOrInterfaceDeclaration( ModifierSet.PUBLIC, false,
                                                 getClassData().getCurrentClass() );
        ASTHelper.addTypeDeclaration( getClassData().getCurrentCompilationUnit(),
                                      newClassDecl );

        int mods = ModifierSet.PUBLIC | ModifierSet.STATIC;

        MethodDeclaration mainMethodDecl =
                new MethodDeclaration( mods, new VoidType(), "main" );
        BlockStmt mainBody = new BlockStmt();
        mainMethodDecl.setBody( mainBody );

        ConstructorDeclaration ctor =
                new ConstructorDeclaration( ModifierSet.PUBLIC,
                                            newClassDecl.getName() );
        ASTHelper.addMember( newClassDecl, ctor );
        BlockStmt ctorBody = new BlockStmt();
        ctor.setBlock( ctorBody );

        Type type = ASTHelper.createReferenceType( "String", 1 );
        VariableDeclaratorId id = new VariableDeclaratorId( "args" );
        japa.parser.ast.body.Parameter parameter =
                new japa.parser.ast.body.Parameter( type, id );
        // Wire everything together.
        ASTHelper.addParameter( mainMethodDecl, parameter );
        ASTHelper.addMember( newClassDecl, mainMethodDecl );

        // List< PropertyDecl > topLevelProperties =
        // new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection(
        // Frontend.getTopLevelProperties( this.model ) ) );
        // PropertyDecl toExecute = topLevelProperties.get( 0 );
        // String className = toExecute.ty().toJavaString();
        // String instanceName = toExecute.name();
        // if ( instanceName == null || instanceName.isEmpty() ) {
        // instanceName = className + ( counter++ );
        // }

        addExtends( newClassDecl, globalName );

        StringBuffer stmtsMain = new StringBuffer();

        // stmtsMain.append( "Main scenario = new Main();" );
        // stmtsMain.append( "scenario.amTopEventToSimulate = true;" );
        // stmtsMain.append( "System.out.println(\"===FULLOUTPUT===\" );" );
        // stmtsMain.append( "scenario.satisfy( true, null );" );
        // stmtsMain.append( "System.out.println(\"===RESULTS===\" );" );
        // stmtsMain.append( "System.out.println(scenario.kSolutionString());"
        // );
        String targetDirectory = getPackageSourcePath( null );
        String y = "      JSONObject json = new JSONObject();\n";
        if ( !this.processStdoutAndStderr ) {
            y += "Timepoint.setUnits(\"milliseconds\");\n" +
                 "Timepoint.setEpoch(\"Mon Mar 10 03:00:00 PDT 2028\");\n" +
                 "Timepoint.setHorizonDuration(10928118000L);\n";
            y +=    "\n" +
                    "      Main s = new Main();\n" +
                    "      s.amTopEventToSimulate = true;\n" +
                    "      System.out.println(\"===FULLOUTPUT===\" );\n" +
                    "      s.executeAndSimulate();\n" +
                    "      System.out.println(\"===RESULTS===\" );\n" +
                    "      System.out.println(s.kSolutionString());\n" +
                    "\n";
            y +=    "      JSONObject solution = s.kSolutionJson();\n" +
                    "      json.put(\"result\", solution);\n" +
                    "\n" +
                    "      System.out.println(json.toString(4));";
        } else {
            y +=    "        CaptureStdoutStderr c = new CaptureStdoutStderr() {\n" +
                    "            @Override\n" +
                    "            public Object run() {\n" +
                    "                Timepoint.setUnits(\"milliseconds\");\n" +
                    "                Timepoint.setEpoch(\"Mon Mar 10 03:00:00 PDT 2025\");\n" +
                    "                Timepoint.setHorizonDuration(109281180000L);\n" +
                    "                Main scenario = null;\n" +
                    "                try {\n" +
                    "                    scenario = new Main();\n" +
                    "                    scenario.amTopEventToSimulate = true;\n" +
                    (verbose ?
                            "                System.out.println(\"===FULLOUTPUT===\" );\n" : "") +
                    "                    scenario.executeAndSimulate();\n" +
                    "                } catch( Throwable t ) {\n" +
                    "                    t.printStackTrace();\n" +
                    "                }\n" +
                    "                return scenario;\n" +
                    "            }\n" +
                    "        };\n" +
                    "\n" +
                    "        Main s = (Main) c.result;\n" +
                    "\n" +
                    "        String out = c.baosOut.toString();\n" +
                    "        String path = \"" + targetDirectory + File.separator + "solverOutput.log\";\n" +
                    "        FileUtils.stringToFile(out, path);\n" +
                    "\n" +
                    "        File f = new File(path);\n" +
                    "        json.put(\"solverOutFile\",f.getAbsolutePath());\n" +
                    "\n" +
                    "        if ( c.baosErr.toString().length() > 3 ) {\n" +
                    "            JSONArray jarr = json.has(\"solverErrors\") ? json.getJSONArray(\"solverErrors\") : null;\n" +
                    "            if (jarr == null) jarr = new JSONArray();\n" +
                    "            jarr.put(c.baosErr);\n" +
                    "            json.put(\"Solver Errors\", jarr);\n" +
                    "        }\n" +
                    "\n" +
                    (verbose ?
                    "      System.out.println(\"===RESULTS===\" );\n" +
                    "      System.out.println(s.kSolutionString());\n" : "");
            y +=    "      JSONObject solution = s.kSolutionJson();\n" +
                    "      json.put(\"result\", solution);\n" +
                    "\n" +
                    "      System.out.println(json.toString(4));";
        }
        stmtsMain.append(y);


        List< Expression > args = new ArrayList< Expression >();

        ASTHelper.addStmt( ctorBody,
                           new ExplicitConstructorInvocationStmt( false, null,
                                                                  args ) );

        addImport( "gov.nasa.jpl.ae.event.Expression" );
        addImport( "gov.nasa.jpl.ae.util.CaptureStdoutStderr" );
        addImport( "gov.nasa.jpl.mbee.util.FileUtils" );
        addImport( "java.io.File" );
        addImport( "org.json.JSONArray" );
        addImport( "org.json.JSONObject" );

        addStatements( mainBody, stmtsMain.toString() );
    }

    protected static void addExtends( ClassOrInterfaceDeclaration newClassDecl,
                                      String superClass ) {
        if ( newClassDecl.getExtends() == null ) {
            newClassDecl.setExtends( new ArrayList< ClassOrInterfaceType >() );
        }
        newClassDecl.getExtends().add( new ClassOrInterfaceType( superClass ) );
    }

    public String getPackageSourcePath( String projectPath ) {
        if ( projectPath == null ) {
            projectPath = "";
        } else {
            projectPath += File.separator;
        }
        String packagePath =
                getPackageName().replace( '.', File.separatorChar );
        String srcPath = projectPath + "src" + File.separator + packagePath;
        return srcPath;
    }

    public String getPackageName() {
        return this.packageName;
    }

    public void writeFiles( String directory ) {
        javaFiles = writeFiles(this, directory, packageName );
    }

    public static ArrayList<String> writeFiles( KtoJava translator, String directory, String packageName ) {
        ArrayList<String> javaFiles = new ArrayList<String>();
        if ( translator == null ) return javaFiles;
        if ( translator.expressionTranslators == null ) return javaFiles;
        String originalPackageName = translator.packageName;
        for ( Map.Entry<String, JavaToConstraintExpression> e :
              translator.expressionTranslators.entrySet() ) {
            String pName = e.getKey();
            JavaToConstraintExpression xlator = e.getValue();
            ClassData classData = xlator.getClassData();
            Model m = translator.model(pName);
            if ( m == null ) continue;
            translator.packageName = pName;
            ArrayList<String> someJavaFiles =
                    EventXmlToJava.writeFiles(classData, directory, pName );
            if ( someJavaFiles != null ) {
                javaFiles.addAll( someJavaFiles );
            }
        }
        translator.packageName = originalPackageName;
        return javaFiles;
        /*
        if ( translator == null ) {
            return;
        }
        // Figure out where to write the files
        String targetDirectory = translator.getPackageSourcePath( null );
        if ( targetDirectory == null ) {
            if ( directory == null ) {
                targetDirectory = translator.packageName;
            } else {
                targetDirectory = directory + File.separator + translator.packageName;
            }
        }

        // Create the directory for the package where the files will be
        // written
        // and see if the directory exists.
        File targetDirectoryFile = new File( targetDirectory );
        if ( !targetDirectoryFile.exists() ) {
            if ( !targetDirectoryFile.mkdirs() ) {
                System.err.println( "Error! Unable to make package directory: "
                                    + targetDirectoryFile.getAbsolutePath() );
            }
        } else {
            assert targetDirectoryFile.isDirectory();
        }

        // Delete old Java and class files.
        File[] files =
                EventXmlToJava.getJavaFileList( targetDirectoryFile );
        Debug.outln( "Deleting old .java files in "
                     + targetDirectoryFile.getAbsolutePath() + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );
        files = translator.getJavaFiles( targetDirectory, false, false );
        Debug.outln( "Deleting old .class files in "
                     + targetDirectoryFile.getAbsolutePath() + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );
        String binDir = targetDirectoryFile.getAbsolutePath()
                                           .replaceFirst( "([^a-zA-Z])src([^a-zA-Z])",
                                                          "$1bin$2" );
        files = translator.getJavaFiles( binDir, false, false );
        Debug.outln( "Deleting old .class files in " + binDir + ": "
                     + Utils.toString( files ) );
        EventXmlToJava.deleteFiles( files );

        // Now write the files.
        try {
            translator.writeJavaFiles( targetDirectory );
        } catch ( IOException e ) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
     */
    }

    public void writeJavaFiles( String javaPath ) throws IOException {
        EventXmlToJava.writeJavaFiles( javaPath, getClassData() );
    }

    public static File[] getJavaFileList( File path ) {
        File[] fileArr = null;
        assert path.exists();
        fileArr = path.listFiles();
        return fileArr;
    }

    public static File[] getJavaFileList( String javaPath ) {
        File[] fileArr = null;
        File path = new File( javaPath );
        return getJavaFileList( path );
    }

    public File[] getJavaFiles( String javaPath, boolean sourceOrClass,
                                boolean justCurrentClasses ) {
        File[] fileArr = null;
        File path = new File( javaPath );
        if ( javaPath == null ) {
            javaPath = ( sourceOrClass ? "src" : "bin" ) + File.separator
                       + this.packageName;
            File path2 = new File( javaPath );
            if ( !path2.exists() && !sourceOrClass ) {
                javaPath = "src" + File.separator + this.packageName;
                path2 = new File( javaPath );
            }
            if ( path2.exists() ) {
                path = path2;
            }
        }
        assert path.exists();
        if ( !justCurrentClasses ) {
            fileArr = getJavaFileList( path );
            if ( fileArr != null ) {
                List< File > files = new ArrayList< File >();
                for ( File f : fileArr ) {
                    if ( f.getName()
                          .endsWith( sourceOrClass ? ".java" : ".class" ) ) {
                        files.add( f );
                    }
                }
                fileArr = new File[ files.size() ];
                int ctr = 0;
                for ( File f : files ) {
                    fileArr[ ctr++ ] = f;
                }
            }
            return fileArr;
        }

        fileArr = new File[ getClassData().getClasses().size() ];
        if ( !getClassData().getClasses().isEmpty() ) {
            int ctr = 0;
            for ( String clsName : getClassData().getClasses().keySet() ) {
                String filePathName = javaPath.trim() + File.separator + clsName
                                      + ( sourceOrClass ? ".java" : ".class" );
                fileArr[ ctr++ ] = new File( filePathName );
            }
        }
        return fileArr;
    }

    public static JSONObject
           propertyToJSON( PropertyDecl p,
                           Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject property = new JSONObject();
        property.put( "name", p.name() );
        property.put( "type", p.ty().toString() );
        Tuple2< Object, Object > numbers = map.get( p );

        property.put( "line", numbers._1() );
        property.put( "char", numbers._2() );

        property.put( "children", new JSONArray() );

        return property;
    }

    public static JSONObject
           functionToJSON( FunDecl f,
                           Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject function = new JSONObject();
        function.put( "name", f.ident() );
        function.put( "type", "function" );
        Tuple2< Object, Object > numbers = map.get( f );
        function.put( "line", numbers._1() );
        function.put( "char", numbers._2() );
        function.put( "children", new JSONArray() );

        return function;
    }

    public static JSONObject
           entityToJSON( EntityDecl e,
                         Map< MemberDecl, Tuple2< Object, Object > > map ) {
        JSONObject entity = new JSONObject();
        entity.put( "name", e.ident() );
        entity.put( "type", "class" );
        Tuple2< Object, Object > numbers = map.get( e );
        entity.put( "line", numbers._1() );
        entity.put( "char", numbers._2() );
        JSONArray children = new JSONArray();
        List< PropertyDecl > properties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( e.getPropertyDecls() ) );
        for ( PropertyDecl p : properties ) {
            children.put( propertyToJSON( p, map ) );
        }
        List< FunDecl > functions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( e.getFunDecls() ) );
        for ( FunDecl f : functions ) {
            children.put( functionToJSON( f, map ) );
        }

        List< ConstraintDecl > constraints =
                new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( e.getConstraintDecls() ) );
        for ( ConstraintDecl c : constraints ) {
            JSONObject constraint = constraintToJSON( c, map );
            if ( constraint != null ) {
                children.put( constraint );
            }
        }

        List< EntityDecl > entities =
                new ArrayList< EntityDecl >( JavaConversions.asJavaCollection( e.getEntityDecls() ) );
        for ( EntityDecl ent : entities ) {
            JSONObject entJSON = entityToJSON( ent, map );
            if ( entJSON != null ) {
                children.put( entJSON );
            }
        }

        entity.put( "children", children );

        return entity;
    }

    public static JSONObject
           constraintToJSON( ConstraintDecl c,
                             Map< MemberDecl, Tuple2< Object, Object > > map ) {
        if ( c.name().isEmpty() ) {
            return null;
        }
        JSONObject constraint = new JSONObject();
        constraint.put( "name", c.name().get() );
        constraint.put( "type", "req" );
        Tuple2< Object, Object > numbers = map.get( c );

        constraint.put( "line", numbers._1() );
        constraint.put( "char", numbers._2() );

        constraint.put( "children", new JSONArray() );
        return constraint;
    }

    public static JSONObject kToContainmentTree( String k ) {
        Model m = Frontend.getModelFromString( k );
        Map< MemberDecl, Tuple2< Object, Object > > map =
                JavaConversions.mapAsJavaMap( Frontend.getDeclDict( k ) );
        JSONObject tree = new JSONObject();
        JSONArray topDecls = new JSONArray();
        if ( m == null ) {
            tree.put( "tree", topDecls );
            return tree;
        }
        List< EntityDecl > entities =
                new ArrayList< EntityDecl >( JavaConversions.asJavaCollection( Frontend.getEntitiesFromModel( m ) ) );
        List< PropertyDecl > properties =
                new ArrayList< PropertyDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelProperties( m ) ) );
        List< FunDecl > functions =
                new ArrayList< FunDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelFunctions( m ) ) );
        List< ConstraintDecl > constraints =
                new ArrayList< ConstraintDecl >( JavaConversions.asJavaCollection( Frontend.getTopLevelConstraints( m ) ) );

        for ( EntityDecl e : entities ) {
            JSONObject entity = entityToJSON( e, map );
            topDecls.put( entity );
        }
        for ( FunDecl e : functions ) {
            JSONObject function = functionToJSON( e, map );
            topDecls.put( function );
        }

        for ( ConstraintDecl c : constraints ) {
            JSONObject constraint = constraintToJSON( c, map );
            if ( constraint != null ) {
                topDecls.put( constraint );
            }
        }

        for ( PropertyDecl p : properties ) {
            JSONObject property = propertyToJSON( p, map );
            topDecls.put( property );
        }

        tree.put( "tree", topDecls );
        return tree;
    }

    public static void main( String[] args ) {
        String packageName = "generatedCode";
        String kToJavaOutLog = "kToJavaOut.log";
        String writeJavaOutLog = "writeJavaOut.log";

        // System.setOut(new PrintStream(baosOut));
        // System.setErr(new PrintStream(baosErr));

        boolean solve = false;
        boolean containmentTree = false;
        boolean errorInfo = false;
        boolean translate = false;
        boolean runSMT = false;
        boolean verbose = false;
        boolean processStdoutAndStderr = true;

        JSONObject json = new JSONObject();  // This is now a member of KtoJava, so sync up with it!

        String kToExecute = "";
        Boolean areFiles = args.length > 0;
        for ( int i = 0; i < args.length; ++i ) {
            String arg = args[ i ];
            if ( arg.contains( "package" ) ) {
                ++i;
                continue;
            }
            if ( !arg.contains( "--" ) && !FileUtils.exists( arg ) ) {
                areFiles = false;
                break;
            }
        }

        for ( int i = 0; i < args.length; ++i ) {
            String arg = args[ i ];
            if ( !arg.contains( "--" ) ) {
                if ( areFiles ) {
                    try {
                        String k;
                        k = FileUtils.fileToString( arg );
                        kToExecute += k + "\n";
                    } catch ( FileNotFoundException e ) {
                        e.printStackTrace();
                    }
                } else {
                    kToExecute += arg + " ";
                }
            } else {
                String a = arg.toLowerCase();
                if ( a.contains( "tree" ) ) {
                    containmentTree = true;
                } else if ( a.contains( "nosmt" ) ) {
                    runSMT = false;
                } else if ( a.contains( "smt" ) ) {
                    runSMT = true;
                } else if ( a.contains( "solve" ) ) {
                    solve = true;
                } else if ( a.contains( "error" ) ) {
                    errorInfo = true;
                } else if ( a.contains( "verbose" ) ) {
                    verbose = true;
                }
                // look for any of these: '--captureOff' '--noCapture'
                // '--capture off' '--capture=off' '--processOff' '--noProcess'
                // '--process off' '--process=off'
                else if ( a.contains( "capture" ) || a.contains( "process" ) ) {
                    if ( a.contains( "no" ) || a.contains( "off" ) ) {
                        processStdoutAndStderr = false;
                    } else if ( i < args.length - 1 ) {
                        a = args[ i + 1 ].toLowerCase();
                        if ( !a.startsWith( "-" )
                             && ( a.contains( "no" )
                                  || a.contains( "off" ) ) ) {
                            processStdoutAndStderr = false;
                            ++i;
                        }
                    }
                } else if ( a.contains( "package" ) ) {
                    packageName = args[ ++i ];
                }
            }
        }

        if ( solve ) {
            errorInfo = true;
            //translate = true;
            containmentTree = true;
        }
        if ( !containmentTree && !errorInfo && !runSMT && !solve ) {
            containmentTree = true;
            //translate = true;
            errorInfo = true;
            runSMT = true;
            solve = true;
        }


        KtoJava kToJava = null;
        String targetDirectory = "src" + File.separator + packageName;

        if ( errorInfo ) {
            // KtoJava kToJava = new KtoJava( kToExecute, packageName, translate
            // );
            final String kToExecuteC = kToExecute;
            final String packageNameC = packageName;
            final boolean translateC = translate;
            final boolean solveC = solve;
            final boolean errorInfoC = errorInfo;
            final boolean containmentTreeC = containmentTree;
            final boolean verboseC = verbose;
            final boolean runSmtC = runSMT;

            if ( !processStdoutAndStderr ) {
                try {
                    kToJava = new KtoJava(kToExecuteC, packageNameC, translateC, processStdoutAndStderr);
                    kToJava.translateOrRunSmt(runSmtC, !translateC && solveC);
                    json = kToJava.json;
                } catch( Throwable t) {
                    t.printStackTrace();
                }
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        System.out.println("packageName = " + packageNameC);
                        System.out.println("runSMT = " + runSmtC);
                        System.out.println("solve = " + solveC);
                        System.out.println("errorInfo = " + errorInfoC);
                        System.out.println("containmentTree = " + containmentTreeC);
                        System.out.println("translate = " + translateC);
                        System.out.println("verbose = " + verboseC);

                        try {
                            KtoJava kToJava = new KtoJava( kToExecuteC, packageNameC,
                                                translateC, true );
                            kToJava.translateOrRunSmt(runSmtC, !translateC && solveC);
                            return kToJava;
                        } catch ( Throwable t ) {
                            t.printStackTrace();
                        }
                        return null;
                    }
                };
                String out = c.baosOut.toString();
                String err = c.baosErr.toString();
                if ( verbose ) {
                    System.err.println( err );
                    System.out.println( out );
                }
                kToJava = (KtoJava)c.result;
                if ( kToJava == null ) {
                    targetDirectory = "src" + File.separator + packageName;
                } else {

                    json = kToJava.json;
                    targetDirectory = kToJava.getPackageSourcePath(null);
                }
                File d = new File( targetDirectory );
                d.mkdirs();
                String path = targetDirectory + File.separator + kToJavaOutLog;
                FileUtils.stringToFile( out, path );
                File f = new File( path );
                json.put( "kToJavaOutFile", f.getAbsolutePath() );

                // Add errors to JSON
                JSONArray jarr = new JSONArray();
                jarr.put( err );
                json.put( "errors", jarr );

                // Syntax errors not working? Just gives line:col.
                if ( false ) {
                    List< String > syntaxErrorList = syntaxErrors( c.baosErr );
                    String syntaxErrors = String.join( ",", syntaxErrorList );
                    // System.out.println( "===ERRORS===" );

                    StringBuffer sb = new StringBuffer();

                    sb.append( "Syntax Errors: "
                               + ( syntaxErrors.isEmpty() ? "None"
                                                          : syntaxErrors )
                               + "\n" );
                    // Add syntax errors to JSON
                    // if ( !syntaxErrorList.isEmpty() ) {
                    jarr = new JSONArray();
                    for ( String se : syntaxErrorList ) {
                        jarr.put( se );
                    }
                    json.put( "syntaxErrors", jarr );
                    // }
                    if ( !kToJava.typeCheckSucceeded ) {
                        sb.append( "Input k did not type check\n" );
                    }
                    if ( verbose ) {
                        System.out.println( sb.toString() );
                    }
                }
            }

        }
        if ( (translate || solve) && kToJava != null ) {
            final KtoJava k2j = kToJava;
            if ( !processStdoutAndStderr ) {
                k2j.writeFiles( null );
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        k2j.writeFiles( null );
                        return null;
                    }
                };
                JSONArray jarr =
                        json.has( "errors" ) ? json.getJSONArray( "errors" )
                                             : null;
                if ( jarr == null ) jarr = new JSONArray();
                if ( verbose ) {
                    System.err.println( c.baosErr.toString() );
                    System.out.println( c.baosErr.toString() );
                }
                jarr.put( c.baosErr.toString() );
                json.put( "errors", jarr );
                String outWrite = c.baosOut.toString();
                String path =
                        targetDirectory + File.separator + writeJavaOutLog;
                FileUtils.stringToFile( outWrite, path );
                File f = new File( path );
                json.put( "writeJavaOutFile", f.getAbsolutePath() );
            }
        }

        if ( kToJava != null && kToJava.tryingToCompileAndLoadInPlace && solve ) {
            final KtoJava k2j = kToJava;
            if ( !processStdoutAndStderr ) {
                k2j.compileLoadAndRun();
            } else {
                CaptureStdoutStderr c = new CaptureStdoutStderr() {
                    @Override
                    public Object run() {
                        k2j.compileLoadAndRun();
                        return null;
                    }
                };
                JSONArray jarr =
                        json.has( "errors" ) ? json.getJSONArray( "errors" )
                                             : null;
                if ( jarr == null ) jarr = new JSONArray();
                if ( verbose ) {
                    System.err.println( c.baosErr.toString() );
                    System.out.println( c.baosErr.toString() );
                }
                jarr.put( c.baosErr.toString() );
                json.put( "errors", jarr );
                String outWrite = c.baosOut.toString();
                String path =
                        targetDirectory + File.separator + writeJavaOutLog;
                FileUtils.stringToFile( outWrite, path );
                File f = new File( path );
                json.put( "solve", f.getAbsolutePath() );
            }
        }
        if ( containmentTree ) {
            // System.out.println( "===TREE===" );
            JSONObject tree = new JSONObject();
            try {
                tree = kToContainmentTree( kToExecute );
            } catch ( Throwable t ) {
                if ( verbose ) {
                    t.printStackTrace();
                }
                if ( !errorInfo ) {
                    JSONArray jarr =
                            json.has( "errors" ) ? json.getJSONArray( "errors" )
                                                 : null;
                    if ( jarr == null ) jarr = new JSONArray();
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    PrintWriter pw = new PrintWriter( baos );
                    t.printStackTrace( pw );
                    jarr.put( baos.toString() );
                    json.put( "errors", jarr );
                }
            }
            // System.out.println( tree.toString(4) );
            JSONArray jarr =
                    json.has( "tree" ) ? tree.getJSONArray( "tree" ) : null;
            if ( jarr != null ) {
                json.put( "tree", jarr );
            } else {
                json.put( "tree", tree );
            }

        }

        if ( kToJava != null && kToJava.json != json ) {
            System.err.println("WARNING! KtoJava.json is different than the one declared in main()!");
            kToJava.json = json;
        }

        if ( verbose ) {
            System.out.println( "JSON output:" );
        }
        System.out.println( json.toString( 4 ) );
    }

    public void translateOrRunSmt(boolean trySmt, boolean translateToJava) {
        boolean smtSucceeded = false;
        if ( trySmt && typeCheckSucceeded ) {
            smtSucceeded = runSMT();
        }
        if ( !smtSucceeded && translateToJava) {
            translatePackage();
        }
    }

    // Syntax errors not working? Just gives line:col.
    public static List< String > syntaxErrors( ByteArrayOutputStream baos ) {
        return syntaxErrors( baos.toString() );
    }

    public static List< String > syntaxErrors( String baosString ) {
        List< String > errors = new ArrayList< String >();
        Pattern errorPattern = Pattern.compile( "[0-9]+:[0-9]+" );
        Matcher m = errorPattern.matcher( baosString );
        while ( m.find() ) {
            errors.add( m.group( 0 ) );
        }

        return errors;

    }

    public void compileLoadAndRun() {
        String projectPath = null;
        String mainClassString = this.packageName + ".Main";
        Class<?> mainClass = null;
        try {
            mainClass = ClassUtils.classForName(mainClassString);
        } catch (ClassNotFoundException e) {
        }
        if ( mainClass == null ) {
            mainClass = ClassUtils.getClassForName("Main", null, this.packageName, true);
        }
        ClassData classData = this.getClassData();
        ClassLoader loader = this.getClass().getClassLoader();///kToJava
        JavaCompiler compiler =
                ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = (compiler == null ? null : compiler.getStandardFileManager(null, null, null) );

        EventXmlToJava.compileLoadAndRun(this.javaFiles, projectPath, this.packageName,
                                         mainClass, classData, loader, fileManager);
    }
}
